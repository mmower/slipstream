// Auto-generated by Rez v1.8.6
// Do not modify as it will be overwritten when the game is next compiled.

(function() {
  "use strict";
  window.Rez = window.Rez ?? {};

  
  //-----------------------------------------------------------------------------
// Extend JS objects
//-----------------------------------------------------------------------------




  
  
      Boolean.rand = function() {
    return Math.random() < 0.5 ? true : false;
  };

    

  
  
      Object.defineProperty(Object.prototype, "copy", {
        value: function() {
    const deepCopy = (value) => {
      if(value === null || value === undefined || typeof(value) !== 'object') {
        return value;
      } else if(typeof(value.copy) === 'function') {
        return value.copy();
      } else {
        return Object.copy.call(value);
      }
    };

    // Handle null or undefined
    if (this === null || typeof this === 'undefined') {
        return this;
    }

    if(this instanceof Set) {
      return new Set([...this].map(item => deepCopy(item)));
    }

    // Handle array
    if (Array.isArray(this)) {
      return this.map(item => deepCopy(item));
    }

    // Handle object
    if (typeof this === 'object') {
        // Use the same constructor as the original object to preserve prototype chain
        let copiedObj;

        try {
            // Try to create a new instance using the constructor
            copiedObj = new this.constructor();
        } catch (e) {
            // If constructor fails, fall back to creating object with same prototype
            copiedObj = Object.create(Object.getPrototypeOf(this));
        }

        // Copy all enumerable properties
        for (const key in this) {
            if (this.hasOwnProperty(key)) {
                copiedObj[key] = deepCopy(this[key]);
            }
        }

        // Copy non-enumerable properties
        Object.getOwnPropertyNames(this).forEach(key => {
            if (!copiedObj.hasOwnProperty(key)) {
                const descriptor = Object.getOwnPropertyDescriptor(this, key);
                if (descriptor) {
                    // For accessor properties (getters/setters), preserve them
                    if (descriptor.get || descriptor.set) {
                        Object.defineProperty(copiedObj, key, descriptor);
                    } else {
                        // For data properties, deep copy the value
                        Object.defineProperty(copiedObj, key, {
                            value: deepCopy(descriptor.value),
                            writable: descriptor.writable,
                            enumerable: descriptor.enumerable,
                            configurable: descriptor.configurable
                        });
                    }
                }
            }
        });

        // Copy symbol properties
        Object.getOwnPropertySymbols(this).forEach(sym => {
            const descriptor = Object.getOwnPropertyDescriptor(this, sym);
            if (descriptor) {
                // For accessor properties (getters/setters), preserve them
                if (descriptor.get || descriptor.set) {
                    Object.defineProperty(copiedObj, sym, descriptor);
                } else {
                    // For data properties, deep copy the value
                    Object.defineProperty(copiedObj, sym, {
                        value: deepCopy(descriptor.value),
                        writable: descriptor.writable,
                        enumerable: descriptor.enumerable,
                        configurable: descriptor.configurable
                    });
                }
            }
        });

        return copiedObj;
    }

    // Handle other primitive types (e.g., string, number, etc.)
    return this;
  }
      });
  

  
  
      Object.defineProperty(Object.prototype, "objMap", {
        value: function(f) {
    const entries = Object.entries(this);
    const new_entries = entries.map(([k, v]) => [k, f(v, k)]);
    return Object.fromEntries(new_entries);
  }
      });
  

  
  
      Object.defineProperty(String.prototype, "dqWrap", {
        value: function() {
    return `"${this}"`;
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "max", {
        value: function() {
    if(this.length === 0) {
      throw new Error("Cannot get the max of an empty array!");
    }

    return this.reduce((a, b) => Math.max(a, b));
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "min", {
        value: function() {
    if(this.length === 0) {
      throw new Error("Cannot get the min of an empty array!");
    }

    return this.reduce((a, b) => Math.min(a, b));
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "englishList", {
        value: function(amp) {
    let connector = "and";
    if(amp != undefined && amp) {
      connector = "&";
    }

    switch(this.length) {
      case 0:
        return "";

      case 1:
        return `${this[0]}`;

      case 2:
        return this.join(` ${connector} `);

      default:
        return this.slice(0, -1).join(", ") + `, ${connector} ` + this[this.length - 1];
    }
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "remove", {
        value: function(elem) {
    const idx = this.indexOf(elem);
    if(idx !== -1) {
      this.splice(idx, 1);
    }
    return this;
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "fyShuffle", {
        value: function() {
    let idx = this.length;
    while(--idx > 0) {
      const rand_idx = Math.floor(Math.random() * (idx+1));
      [this[rand_idx], this[idx]] = [this[idx], this[rand_idx]];
    }
    return this;
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "randomElement", {
        value: function() {
    return this.at(Math.floor(Math.random() * this.length));
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "randomIndex", {
        value: function() {
    return Math.floor(Math.random() * this.length);
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "frequencies", {
        value: function() {
    const freqs = new Map();
    for(const v of this) {
      let val = freqs.get(v);
      if(typeof(val) == "undefined") {
        val = 1;
      } else {
        val = val + 1;
      }
      freqs.set(v, val);
    }
    return freqs;
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "normalizePTable", {
        value: function() {
    const sum = this.reduce((sum, [value, freq]) => sum + freq, 0);

    let cumProbability = 0.0;
    return this.map(([value, freq]) => {
      cumProbability += freq/sum;
      return [value, cumProbability];
    });
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "sum", {
        value: function() {
    return this.reduce((a, b) => a+b, 0);
  }
      });
  

  
  
      Array.equals = function(a, b) {
    return Array.isArray(a) &&
        Array.isArray(b) &&
        a.length === b.length &&
        a.every((val, index) => val === b[index]);
  };

    

  
  
      Object.defineProperty(Array.prototype, "startsWithSequence", {
        value: function(sequence) {
    return this.slice(0, sequence.length).every((value, index) => value === sequence[index]);
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "to_pairs", {
        value: function() {
    let pairs = [];
    for(let i = 0; i < this.length; i += 2) {
      if(this[i + 1] !== undefined) {
        pairs.push([this[i], this[i + 1]]);
      }
    }
    return pairs;
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "take", {
        value: function(n) {
    if(this.length < n) {
      throw `Cannot take ${n} items from an array containing ${this.length} items!`;
    }

    return Math.range(1, n).map((_) => {return this.shift()});
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "refs", {
        value: function() {
    return this.map((id) => $(id));
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "ids", {
        value: function() {
    return this.map((obj) => obj.id);
  }
      });
  

  
  
      Array.nOf = function(length, def_value) {
    if(typeof(def_value) === "function") {
      return Array.from({length: length}, def_value);
    } else {
      return Array.from({length: length}, () => def_value);
    }
  };

    

  
  
      Object.defineProperty(Array.prototype, "sample", {
        value: function(percentage) {
    if (!Array.isArray(this) || this.length === 0 || percentage <= 0) {
      return []; // Return an empty array for invalid input
    }

    const sampleSize = Math.ceil(this.length * (percentage / 100));
    const result = [];
    const indicesUsed = new Set();

    while (result.length < sampleSize && indicesUsed.size < this.length) {
      const randomIndex = Math.floor(Math.random() * this.length);
      if (!indicesUsed.has(randomIndex)) {
        indicesUsed.add(randomIndex);
        result.push(this[randomIndex]);
      }
    }

    return result;
  }
      });
  

  
  
      Array.zip = function(ar1, ar2) {
    return ar1.map((value, idx) => [value, ar2[idx]]);
  };

    

  
  
      Object.defineProperty(Array.prototype, "splitWith", {
        value: function(pred) {
    return this.reduce(
        (acc, item) => {
          acc[pred(item) ? 0 : 1].push(item);
          return acc;
        },
        [[], []]
      );
  }
      });
  

  
  
      Object.defineProperty(Array.prototype, "pushWithLimit", {
        value: function(el, lim) {
    this.push(el);
    if(this.length > lim) {
      this.shift();
    }
    return this;
  }
      });
  

  
  
      Object.defineProperty(String.prototype, "beginsWithConsonant", {
        value: function() {
    return /^[^aeiouAEIOU]/.test(this);
  }
      });
  

  
  
      Object.defineProperty(String.prototype, "beginsWithVowel", {
        value: function() {
    return /^[aeiouAEIOU]/.test(string);
  }
      });
  

  
  
      Object.defineProperty(String.prototype, "toTitleCase", {
        value: function() {
    return this.replace(/(^|\s)\S/g, l => l.toUpperCase());
  }
      });
  

  
  
      Object.defineProperty(String.prototype, "possessive", {
        value: function() {
    if(this.endsWith("s")) {
      return this + "'";
    } else {
      return this + "'s";
    }
  }
      });
  

  
  
      Object.defineProperty(String.prototype, "toCamelCase", {
        value: function() {
    return this.replace(/[_.-](\w|$)/g, function (_, x) {
	  	return x.toUpperCase();
	  });
  }
      });
  

  
  
      Object.defineProperty(String.prototype, "toPascalCase", {
        value: function() {
    const camelCase = this.replace(/[_.-](\w|$)/g, function (_, x) {
	  	return x.toUpperCase();
	  });
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
  }
      });
  

  
  
      Object.defineProperty(String.prototype, "toKebabCase", {
        value: function() {
    return this
      .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)
      .map(x => x.toLowerCase())
      .join('-');
  }
      });
  

  
  
      Object.defineProperty(String.prototype, "toSnakeCase", {
        value: function() {
      return this
      .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)
      .map(x => x.toLowerCase())
      .join('_');
  }
      });
  

  
  
      Object.defineProperty(String.prototype, "parseTime", {
        value: function() {
    const time_components = this.match( /(\d+)(?::(\d\d))?\s*(p?)/ );
    const hour_s = time_components[1];
    if(typeof(hour_s) == "undefined") {
      throw "Invalid time string (hour): '" + this + "'";
    }
    const hour = parseInt(hour_s);
    if(hour == NaN) {
      throw "Invalid time string (hour): '" + this + "'";
    }

    const mins_s = time_components[2];
    if(typeof(mins_s) == "undefined") {
      throw "Invalid time string (mins): '" + this + "'";
    }

    const mins = parseInt(mins_s);
    if(typeof(mins) == NaN) {
      throw "Invalid time string (mins): '" + this + "'";
    }

    return [hour, mins];
  }
      });
  

  
  
      String.randomId = function() {
    const rand = window.crypto.getRandomValues(new Uint32Array(1))[0];
    return rand.toString(16);
  };

    

  
  
      Object.defineProperty(String.prototype, "wrapWith", {
        value: function(prefix, suffix) {
    suffix = suffix ?? prefix;
    return `${prefix}${this}${suffix}`;
  }
      });
  

  
  
      Object.defineProperty(String.prototype, "indefiniteArticle", {
        value: function() {
    return this.beginsWithConsonant() ? "a" : "an";
  }
      });
  

  
  
      Object.defineProperty(Set.prototype, "union", {
        value: function(otherSet) {
    return new Set([...this, ...otherSet]);
  }
      });
  

  
  
      Object.defineProperty(Set.prototype, "intersection", {
        value: function(otherSet) {
    return new Set([...this].filter(x => otherSet.has(x)));
  }
      });
  

  
  
      Object.defineProperty(Set.prototype, "difference", {
        value: function(otherSet) {
    return new Set([...this].filter(x => !otherSet.has(x)));
  }
      });
  

  
  
      Object.defineProperty(Set.prototype, "equals", {
        value: function(otherSet) {
    return this.size === otherSet.size &&
    [...this].every((x) => otherSet.has(x));
  }
      });
  

  
  
      Object.defineProperty(Set.prototype, "hasSubset", {
        value: function(otherSet) {
    return this.intersection(otherSet).equals(otherSet);
  }
      });
  

  
  
      Object.defineProperty(Number.prototype, "ordinal", {
        value: function() {
    const lastDigit = this % 10;
    const secondLastDigit = Math.floor((this % 100) / 10);

    if (lastDigit === 1 && secondLastDigit !== 1) {
      return this + 'st';
    } else if (lastDigit === 2 && secondLastDigit !== 1) {
      return this + 'nd';
    } else if (lastDigit === 3 && secondLastDigit !== 1) {
      return this + 'rd';
    } else {
      return this + 'th';
    }
  }
      });
  

  
  
      Object.defineProperty(Number.prototype, "roundp", {
        value: function(precision) {
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(this * multiplier) / multiplier;
  }
      });
  

  
  
      Object.defineProperty(Number.prototype, "cl_avg", {
        value: function(rounds) {
    rounds ??= 2;
    const f = Math.random() < 0.5 ? Math.ceil : Math.floor;
    return f(this/rounds);
  }
      });
  

  
  
      Object.defineProperty(Number.prototype, "r2nh", {
        value: function() {
    return Math.round(this * 2) / 2;
  }
      });
  

  
  
      Object.defineProperty(Number.prototype, "dist_round", {
        value: function() {
    return Math.dist_round(this);
  }
      });
  

  
  
      Object.defineProperty(Number.prototype, "round_to_nearest", {
        value: function(n) {
    if(n === 0) {
      return this;
    } else {
      return Math.round(this / n) * n;
    }
  }
      });
  

  
  
      Object.defineProperty(Number.prototype, "times", {
        value: function(f) {
    for(let ix = 0; ix < this; ix++) {
      f(ix);
    }
  }
      });
  

  
  
      Math.perc = function(p) {
    return Math.random() <= (p/100);
  };

    

  
  
      Math.div = function(n, d) {
    return Math.floor(n/d);
  };

    

  
  
      Math.div_mod = function(n, d) {
    const div = Math.floor(n/d);
    const mod = n % d;
    return [div, mod];
  };

    

  
  
      Math.range = function(from, to, step) {
    step ??= 1;

    if(from>to) {
      [from, to] = [to, from];
    }

    return Array.from(
      {length: (to-from)/step+1},
      (_, i) => from + (i * step));
  };

    

  
  
      Math.dist_round = function(v) {
    if(Math.random() < 0.5) {
      return Math.ceil(v);
    } else {
      return Math.floor(v);
    }
  };

    

  
  
      Math.rand_int = function(lim) {
    return Math.floor(Math.random() * lim);
  };

    

  
  
      Math.rand_int_between = function(min, max) {
    if(min > max) {
      [min, max] = [max, min]
    }
    return Math.floor(min + Math.random() * (max - min + 1));
  };

    

  
  
      Math.rand_f_between = function(min, max) {
    if(min > max) {
      [min, max] = [max, min]
    }

    return min + (Math.random() * (max - min));
  };

    

  
  
      Math.cl_rand_f_between = function(min, max, rounds) {
    rounds = rounds ?? 2;
    let total = 0;
    for(let i = 0; i < rounds; i+= 1) {
      total += Math.rand_f_between(min, max);
    }
    return total/rounds;
  };

    

  
  
      Math.cl_rand_int = function(lim) {
    const v1 = Math.rand_int(lim);
    const v2 = Math.rand_int(lim);
    return (v1+v2)/2;
  };

    

  
  
      Math.cl_rand_int_between = function(lo, hi) {
    const v1 = Math.rand_int_between(lo, hi);
    const v2 = Math.rand_int_between(lo, hi);
    return Math.dist_round((v1+v2)/2);
  };

    

  
  
      Math.clamped_sub = function(value, sub, min) {
    return Math.max(value-sub, min);
  };

    

  
  
      Math.clamped_add = function(value, add, max) {
    return Math.min(value+add, max);
  };

    

  
  
      Math.alter = function(value, change, min, max) {
    return Math.max(Math.min(value+change, max), min);
  };

    

  
  
      Math.samplePTable = function(table) {
    if(!Array.isArray(table)) {
      throw new Error(`Tried to sample an ${typeof(table)} which is expected be an array [[value, prob], [value, prob], ...]`);
    }

    const p = Math.random();
    const idx = table.findIndex((pair) => p <= pair[1]);
    if (idx == -1) {
      throw new Error("Invalid p_table. Must contain range 0<n<1");
    }
    return table[idx][0];
  };

    


  function normalizeRefs(value) {
  // Primitives pass through
  if (value === null || value === undefined || typeof value !== 'object') {
    return value;
  }

  // Check for pure ref: {$ref: "id"} with only that property
  if ('$ref' in value && Object.keys(value).length === 1) {
    return value.$ref;
  }

  // Handle Arrays
  if (Array.isArray(value)) {
    return value.map(normalizeRefs);
  }

  // Handle Sets - must recreate
  if (value instanceof Set) {
    return new Set([...value].map(normalizeRefs));
  }

  // Handle plain objects - recurse into properties
  if (value.constructor === Object) {
    const result = {};
    for (const [k, v] of Object.entries(value)) {
      result[k] = normalizeRefs(v);
    }
    return result;
  }

  // Other object types (RezDie, Map, etc.) pass through unchanged
  return value;
}

class RezBasicObject {
  static #game;

  #id;
  #element;
  #attributes;
  #changedAttributes;
  #initialized;

  constructor(element, id, attributes) {
    this.#element = element;
    this.#id = id;
    this.#attributes = normalizeRefs(attributes);
    this.#changedAttributes = new Set();
    this.#initialized = false;
  }

  static set game(game) {
    RezBasicObject.#game = game;
  }

  static get game() {
    return RezBasicObject.#game;
  }

  get game() {
    return RezBasicObject.game;
  }

  get element() {
    return this.#element;
  }

  get id() {
    return this.#id;
  }

  get ref() {
    return {$ref: this.id};
  }

  get attributes() {
    return this.#attributes;
  }

  get changedAttributes() {
    return this.#changedAttributes;
  }

  get isInitialized() {
    return this.#initialized;
  }

  /**
   * @function needsArchiving
   * @memberof basic_object
   * @returns {boolean} true if this object requires archiving
   */
  get needsArchiving() {
    return this.#changedAttributes.size > 0;
  }

  archiveInto(archive) {
    if(this.needsArchiving) {
      archive[this.id] = [... this.#changedAttributes].reduce((archive, attrName) => {
        let value = this.getAttribute(attrName);
        if(typeof(value) === "function") {
          value = {
            json$safe: true,
            type: "function",
            value: value.toString()
          }
        }
        archive[attrName] = value;
        return archive;
      }, {});
    }
  }

  loadData(attrs) {
    if(typeof attrs !== "object") {
      throw new Error("Attempting to load attributes from improper object!");
    }
    for (const [attrName, attrValue] of Object.entries(attrs)) {
      if(typeof(attrValue) === "object" && attrValue.hasOwnProperty("json$safe")) {
        if(attrValue["type"] === "function") {
          const functionBody = attrValue.value;
          try {
            // Use the Function constructor to create a new function
            const restoredFunction = new Function(`return (${functionBody})`)();
            this.setAttribute(attrName, restoredFunction);
          } catch (error) {
            console.error(`Failed to restore function for attribute '${attrName}':`, error);
          }
        } else {
          console.error(`Failed to restore unknwon type for attribute '${attrName}' (${attrValue["type"]})`);
        }
      } else {
        this.setAttribute(attrName, attrValue);
      }
    }
  }

  initAll() {
    for (let initLevel of this.game.initLevels()) {
      this.init(initLevel);
    }
  }

  init(level) {
    const initMethod = `init${level}`;
    if (typeof this[initMethod] == "function") {
      this[initMethod]();
    }
  }

  init0() {
    this.createStaticProperties();
    this.createDynamicProperties();
  }

  init1() {
    this.initDynamicAttributes();
  }

  init2() {
    // Initialize Mixins
    for(let mixin_ref of this.getAttributeValue("$mixins", [])) {
      const mixin_id = (typeof mixin_ref === "object" && mixin_ref.$ref) ? mixin_ref.$ref : mixin_ref;
      const mixin = window.Rez.mixins[mixin_id];

      // Apply properties
      for (let [propName, propDef] of Object.entries(mixin)) {
        if(propDef.property) {
          this.createCustomProperty(propName, propDef);
        } else if (typeof propDef === 'function') {
          // Apply methods directly
          this[propName] = propDef.bind(this);
        }
      }
    }
  }

  init3() {
    // Templates don't initialise like regular objects
    if (!this.isTemplateObject()) {
      this.elementInitializer();
      this.runEvent("init", {});
    }
  }

  init4() {
    this.#initialized = true;
  }

  /**
   * @function createStaticProperty
   * @memberof basic_object
   * @param {string} attr_name - name of the attribute to create a corresponding property for
   * @description use this to create a JS property backed by a Rez attribute
   */
  createStaticProperty(attrName) {
    Object.defineProperty(this, attrName, {
      get: function () {
        return this.getAttribute(attrName);
      },
      set: function (value) {
        this.setAttribute(attrName, value);
      },
      configurable: true,
    });

    if (attrName.endsWith("_id")) {
      const directAttrName = attrName.slice(0, -3);
      Object.defineProperty(this, directAttrName, {
        get: function () {
          const ref_id = this.getAttribute(attrName);
          return $(ref_id);
        },
        set: function (ref) {
          if(ref?.id == null) {
            throw new Error("Cannot assign an empty ID ref");
          }
          this.setAttribute(attrName, ref.id);
        },
      });
    } else if(attrName.endsWith("_die")) {
      const directAttrName = attrName.slice(0, -4);
      const syntheticAttrName = `${directAttrName}_roll`;
      Object.defineProperty(this, syntheticAttrName, {
        get: function() {
          const attr = this.getAttribute(attrName);
          return attr.roll();
        }
      })
    }
  }

  /**
   * @function createStaticProperties
   * @memberof basic_object
   * @description uses basic_object.createStaticProperty to create static properties for all of the objects declared Rez attributes
   */
  createStaticProperties() {
    for(let [attrName, _] of Object.entries(this.attributes)) {
      this.createStaticProperty(attrName);
    }
  }

  /**
   * @function createDynamicProperties
   * @memberof basic_object
   * @description creates synthetic properties to represent dynamic attributes types such as `ptable` and `tracery_grammar`.
   */
  createDynamicProperties() {
    if (this.getAttributeValue("$template", false)) {
      return;
    }

    for (let attrName of Object.keys(this.attributes)) {
      const value = this.getAttribute(attrName);
      if (typeof value == "object") {
        if (value.hasOwnProperty("ptable")) {
          this.createProbabilityTable(attrName, value);
        } else if (value.hasOwnProperty("property")) {
          this.createCustomProperty(attrName, value);
        } else if (value.hasOwnProperty("bht")) {
          this.createBehaviourTreeAttribute(attrName, value);
        }
      }
    }
  }

  initDynamicAttributes() {
    if(this.getAttributeValue("$template", false)) {
      return;
    }

    // Priority is fixed by the Rez compiler to be between 1 & 10
    const dyn_initializers = [[], [], [], [], [], [], [], [], [], []];
    const copy_initializers = [[], [], [], [], [], [], [], [], [], []];

    for(let attrName of Object.keys(this.attributes)) {
      const value = this.getAttribute(attrName);
      if(typeof value == "object") {
        if(value.hasOwnProperty("initializer")) {
          const prio = parseInt(value["priority"]);
          dyn_initializers[prio-1].push([attrName, value]);
        } else if(value.hasOwnProperty("$copy")) {
          const prio = parseInt(value["priority"]);
          copy_initializers[prio-1].push([attrName, value]);
        }
      }
    }

    copy_initializers.flat().forEach(
      ([attrName, elem_ref]) => this.createAttributeByCopying(attrName, elem_ref)
    );

    dyn_initializers.flat().forEach(
      ([attrName, value]) => this.createDynamicallyInitializedAttribute(attrName, value)
    );
  }

  createProbabilityTable(attrName, value) {
    delete this[attrName];

    const pTable = JSON.parse(value["ptable"]);

    Object.defineProperty(this, attrName, {
      get: function () {
        const p = Math.random();
        const idx = pTable.findIndex((pair) => p <= pair[1]);
        if (idx == -1) {
          throw new Error("Invalid p_table. Must contain range 0<n<1");
        }

        return pTable[idx][0];
      },
    });

    Object.defineProperty(this, `${attrName}_roll`, {
      get: function () {
        const p = Math.random();
        const idx = pTable.findIndex((pair) => p <= pair[1]);
        if(idx == -1) {
          throw new Error("Invalid p_table. Must contain range 0<n<1");
        }

        return { p: p, obj: pTable[idx][0] };
      },
    });
  }

  createCustomProperty(attrName, value) {
    delete this[attrName];
    const propertyDef = value["property"];
    const propertySrc = `function() {${propertyDef}}`;
    eval(`Object.defineProperty(this, "${attrName}", {get: ${propertySrc}})`);
  }

  createDynamicallyInitializedAttribute(attrName, value) {
    if(value.constructor == RezDie) {
      this.setAttribute(attrName, value.roll(), false);
    } else {
      const initializerDef = value["initializer"];
      const initializerSrc = `(function() {${initializerDef}}).call(this)`;
      this.setAttribute(attrName, eval(initializerSrc), false);
    }
  }

  createAttributeByCopying(attrName, value) {
    const elem_ref = value["$copy"];
    const source = $(elem_ref);
    this.setAttribute(attrName, source.addCopy().id);
  }

  createBehaviourTreeAttribute(attrName, value) {
    delete this[attrName];

    const tree = this.instantiateBehaviourTree(value["bht"]);
    Object.defineProperty(this, attrName, {
      get: function() {
        return tree;
      }
    });
  }

  instantiateBehaviourTree(treeSpec) {
    const behaviour_template = $(treeSpec["behaviour"], true);
    const options = treeSpec["options"];
    const children = treeSpec["children"].map((spec) => this.instantiateBehaviourTree(spec));

    return behaviour_template.instantiate(this, options, children);
  }

  /**
   * @function elementInitializer
   * @memberof basic_object
   * @description objects using basic_object as a prototype should define their own elementInitializer function to handle any element-specific initialization
   */
  elementInitializer() {}

  addToGame() {
    $game.addGameObject(this);
    return this;
  }

  /**
   * @function copyAssigningId
   * @memberof basic_object
   * @param {string} id the id to assign to the copy
   * @description creates a copy of this object. If this object has `$template: true` the copy will have `$template: false`. The copy will also be assigned a new attribute `$original_id` containing the id of this object.
   * @returns {object} copy of the current object
   */
  copyAssigningId(id) {
    const attributes = this.attributes.copy();
    const copy = new this.constructor(id, attributes);
    copy.setAttribute("$auto_id_idx", 0, false);
    copy.setAttribute("$template", false, false);
    copy.setAttribute("$original_id", this.id, false);
    copy.initAll();
    copy.runEvent("copy", { original: this });
    return copy;
  }

  /**
   * @function getNextAutoId
   * @memberof basic_object
   * @description returns the next auto id in the sequence
   */
  getNextAutoId() {
    const lastId = this.getAttribute("$auto_id_idx");
    const nextId = lastId + 1;
    this.setAttribute("$auto_id_idx", nextId);
    return this.id + "_" + nextId;
  }

  /**
   * @function copyWithAutoId
   * @memberof basic_object
   * @description creates a copy of this object that is assigned an ID automatically. In all other respects its behaviour is identical to `copyAssigningId`
   * Copies an object with an auto-generated ID
   */
  copyWithAutoId() {
    return this.copyAssigningId(this.getNextAutoId());
  }

  addCopy() {
    return this.copyWithAutoId().addToGame();
  }

  unmap() {
    $game.unmapObject(this);
    return this;
  }

  unmap_attr(attr_name) {
    if(!attr_name.endsWith("_id")) {
      throw new Error("Cannot unmap attributes that do not relate to an element id!");
    }

    if(!this.hasOwnProperty(attr_name)) {
      throw new Error("Cannot unmap attribute not defined on this object!");
    }

    const related_obj = $(this[attr_name], true);

    this[attr_name] = null;
    related_obj.unmap();
  }

  /**
   * @function isTemplateObject
   * @memberof basic_object
   * @description returns the value of the `$template` attribute
   * @returns {boolean} true if this object has a $template attribute with value true
   */
  isTemplateObject() {
    return this.getAttributeValue("$template", false);
  }

  /**
   * @function eventHandler
   * @memberof basic_object
   * @param {string} event_name name of the event whose handler should be returned
   * @returns {function|undefined} event handle function or undefined
   * @description Returns the event handler function stored in attribute "on_<event_name>" or undefined if no handler is present
   */
  eventHandler(eventName) {
    return this[`on_${eventName}`];
  }

  /**
   * @function willHandleEvent
   * @memberof basic_object
   * @param {string} event_name name of the event to check for a handler, e.g. "speak"
   * @returns {boolean} true if this object handles the specified event
   * @description Returns `true` if this object defines an event handler function for the given event_name
   */
  willHandleEvent(eventName) {
    const handler = this.eventHandler(eventName);
    const doesHandleEvent = handler != null && typeof handler == "function";
    return doesHandleEvent;
  }

  /**
   * @function runEvent
   * @memberof basic_object
   * @param {string} event_name name of the event to run, e.g. "speak"
   * @param {object} params object containing event params
   * @returns {*|boolean} returns a response object, or false if the event was not handled
   * @description attempts to run the event handler function for the event name, passing the specified params to the handler
   */
  runEvent(eventName, params) {
    if(RezBasicObject.game.$debug_events) {
      console.log("Run on_" + eventName + " handler on " + this.id);
    }
    let handler = this.eventHandler(eventName);
    if(handler != null && typeof handler == "function") {
      return handler(this, params);
    } else {
      return false;
    }
  }

  /**
   * @function hasAttribute
   * @memberof basic_object
   * @param {string} name name of the attribute
   * @returns {boolean} true if the object defines the specified attribute
   */
  hasAttribute(attrName) {
    return this.attributes.hasOwnProperty(attrName);
  }

  /**
   * @function getAttribute
   * @memberof basic_object
   * @param {string} name name of the attribute
   * @returns {*} attribute value
   * @description returns the value of the attribute with the given name. If no such attribute is present returns `undefined`
   */
  getAttribute(name) {
    const attr = this.attributes[name];
    return attr;
  }

  /**
   * @function getAttributeValue
   * @memberof basic_object
   * @param {string} name name of the attribute
   * @param {*} default_value value to return if no such attribute is present
   * @returns {*} attribute value
   * @description returns the value of the attribute with the given name. If no such value is present it returns the default value. If no default value is given it throws an exception.
   */
  getAttributeValue(name, defaultValue) {
    const attr = this.getAttribute(name);
    if(typeof attr == "undefined") {
      if(typeof defaultValue == "undefined") {
        throw new Error(`Attempt to get value of attribute |${name}| which is not defined on |${this.id}|`);
      } else {
        return defaultValue;
      }
    } else if(typeof attr == "function") {
      return attr(this);
    } else if(attr.constructor == RezDie) {
      return attr.roll();
    } else {
      return attr;
    }
  }

  /**
   * @function getObjectViaAttribute
   * @memberof basic_object
   * @param {string} name attribute name
   * @param {*} default_value
   */
  getObjectViaAttribute(name, defaultValue) {
    const id = this.getAttributeValue(name, defaultValue);
    return this.game.getGameObject(id);
  }

  /**
   * @function setAttribute
   * @memberof basic_object
   * @param {string} attr_name name of attribute to set
   * @param {*} new_value value for attribute
   * @param {boolean} notify_observers whether observers should be notified that the value has changed
   */
  setAttribute(attrName, newValue, notifyObservers = true) {
    if(typeof newValue == "undefined") {
      throw new Error(`Call to setAttribute(${attrName}, â€¦) with undefined value!`);
    }

    const oldValue = this.attributes[attrName];
    this.attributes[attrName] = newValue;
    this.changedAttributes.add(attrName);

    if(notifyObservers) {
      this.runEvent("set_attr", {attrName: attrName, oldValue: oldValue, newValue: newValue});
      this.game.elementAttributeHasChanged(
        this,
        attrName,
        oldValue,
        newValue
      );
    }
  }

  addTag(tag) {
    let tags = this.getAttribute("tags");
    if(!tags) {
      tags = new Set([tag]);
    } else {
      tags.add(tag);
    }

    this.setAttribute("tags", tags);
    this.game.indexObjectForTag(this, tag);
  }

  removeTag(tag) {
    let tags = this.getAttribute("tags");
    if(!tags) {
      tags = new Set();
    } else {
      tags.delete(tag);
    }

    this.setAttribute("tags", tags);
    this.game.unindexObjectForTag(this, tag);
  }

  /**
   * @function setTags
   * @memberof basic_object
   * @param {set} tags tags the object should have after the call
   */
  setTags(newTags) {
    newTags = new Set(newTags); // Just in case they are passed as an array
    const oldTags = this.getAttributeValue("tags", new Set());

    const tagsToRemove = oldTags.difference(newTags);
    tagsToRemove.forEach((tag) => this.removeTag(tag));

    const tagsToAdd = newTags.difference(oldTags);
    tagsToAdd.forEach((tag) => this.addTag(tag));
  }

  getRelationshipWith(targetId) {
    return this.game.getRelationship(this.id, targetId);
  }

  /**
   * @function applyEffect
   * @memberof basic_object
   * @param {string} effectId
   * @param {string} slotId
   * @param {string} itemId
   */
  applyEffect(effectId, slotId, itemId) {
    console.log(
      "Been asked to apply effect |" +
        effectId +
        "| from item |" +
        itemId +
        "| to |" +
        this.id +
        "|"
    );
  }

  /**
   * @function removeEffect
   * @memberof basic_object
   * @param {string} effect_id
   * @param {string} slotId
   * @param {string} itemId
   */
   removeEffect(effectId, slotId, itemId) {
    console.log(
      "Been asked to remove effect |" +
        effectId +
        "| from item |" +
        itemId +
        "| to |" +
        this.id +
        "|"
    );
  }
}

const _placeHolderValue = new RezBasicObject("placeholder", "$place_holder_value", {});

window.Rez.RezBasicObject = RezBasicObject;

//-----------------------------------------------------------------------------
// Actor
//-----------------------------------------------------------------------------

class RezActor extends RezBasicObject {
  constructor(id, attributes) {
    super("actor", id, attributes);
  }

  /**
   * @function checkItem
   * @memberof RezActor
   * @param {string} inventory_id
   * @param {string} slot_id
   * @param {string} item_id
   * @returns {RezDecision}
   * @description when it is attempted to put the specified item into the
   * specified inventory slot, call this actors 'on_accept_item' event handler
   * to give the actor the opportunity to decide whether to accept it or not.
   *
   * The params passed to the event handler are:
   * decision
   * inventory_id
   * slot_id
   * item_id
   *
   * The RezDecision will default to yes. The event handler should return an
   * appropriate RezDecision.
   */
  checkItem(inventoryId, slotId, itemId) {
    const decision = new RezDecision("Filter Item");
    decision.default_yes();
    if (this.willHandleEvent("accept_item")) {
      this.runEvent("accept_item", {
        decision: decision,
        inventoryId: inventoryId,
        slotId: slotId,
        itemId: itemId,
      });
    }
    return decision;
  }

  /**
   * @function elementInitializer
   * @memberof RezActor
   * @description initializes properties of RezActor
   */
  elementInitializer() {
    if (this.hasAttribute("initial_location")) {
      this.moveTo(this.getAttributeValue("initial_location"));
    }
  }

  /**
   * @function moveTo
   * @memberof RezActor
   * @param {string} to_location_id
   * @description moves this actor to a new location
   */
  moveTo(destLocationId) {
    console.log(`Moving |${this.id}| to |${destLocationId}|`);

    if (this.hasAttribute("location_id")) {
      const fromLocationId = this.getAttributeValue("location_id");
      this.runEvent("leave", {location_id: fromLocationId});
      const fromLocation = $(fromLocationId);
      fromLocation.runEvent("leave", { actor_id: this.id });
    }

    this.setAttribute("location_id", destLocationId);
    this.runEvent("enter", { location_id: destLocationId });
    const destLocation = $(destLocationId);
    destLocation.runEvent("enter", { actor_id: this.id });
  }
}

window.Rez.RezActor = RezActor;

//-----------------------------------------------------------------------------
// Asset
//-----------------------------------------------------------------------------

/**
 * @class RezAsset
 * @extends RezBasicObject
 * @description Represents a media asset in the Rez game engine. Assets can be images, audio, video,
 * or text files. Provides methods for determining asset type and generating HTML elements for display.
 * Asset MIME types are detected during compilation and stored in the $detected_mime_type attribute.
 */
class RezAsset extends RezBasicObject {
  /**
   * @function constructor
   * @memberof RezAsset
   * @param {string} id - unique identifier for this asset
   * @param {object} attributes - asset attributes from Rez compilation including file path and MIME type
   * @description Creates a new asset instance
   */
  constructor(id, attributes) {
    super("asset", id, attributes);
  }

  /**
   * @function assetType
   * @memberof RezAsset
   * @returns {string} the primary asset type (e.g., "image", "audio", "video", "text")
   * @description Returns the primary MIME type category for this asset
   * @throws {Error} if no MIME type information is available
   */
  get assetType() {
    const mime_type = this.getAttributeValue("$detected_mime_type");
    if (typeof mime_type == "undefined") {
      throw new Error(`No MIME information available for asset: ${this.id}`);
    }
    return mime_type.split("/")[0];
  }

  /**
   * @function isImage
   * @memberof RezAsset
   * @returns {boolean} true if this asset is an image
   * @description Determines if this asset is an image file
   */
  isImage() {
    return this.assetType === "image";
  }

  /**
   * @function isAudio
   * @memberof RezAsset
   * @returns {boolean} true if this asset is an audio file
   * @description Determines if this asset is an audio file
   */
  isAudio() {
    return this.assetType === "audio";
  }

  /**
   * @function isVideo
   * @memberof RezAsset
   * @returns {boolean} true if this asset is a video file
   * @description Determines if this asset is a video file
   */
  isVideo() {
    return this.assetType === "video";
  }

  /**
   * @function isText
   * @memberof RezAsset
   * @returns {boolean} true if this asset is a text file
   * @description Determines if this asset is a text file
   */
  isText() {
    return this.assetType === "text";
  }

  /**
   * @function audioTag
   * @memberof RezAsset
   * @throws {Error} audio tags are not yet implemented
   * @description Placeholder for generating HTML audio tags (not yet implemented)
   */
  audioTag() {
    throw new Error(`Audio tags not implemented |${this.id})|`);
  }

  /**
   * @function getWidth
   * @memberof RezAsset
   * @param {number} w - optional width override
   * @returns {number} the width to use for this asset
   * @description Gets the width for this asset, using the provided override if available,
   * falling back to the asset's width attribute.
   * @throws {Error} if no width is specified and no default is provided
   */
  getWidth(w) {
    if (typeof w != "undefined") {
      return w;
    }

    const width = this.getAttribute("width");
    if (typeof width != "undefined") {
      return width;
    }

    throw new Error(`Asked for width of asset |${this.id}| which is not defined and no default was specified.`);
  }

  /**
   * @function getHeight
   * @memberof RezAsset
   * @param {number} h - optional height override
   * @returns {number} the height to use for this asset
   * @description Gets the height for this asset, using the provided override if available,
   * falling back to the asset's height attribute.
   * @throws {Error} if no height is specified and no default is provided
   */
  getHeight(h) {
    if (typeof h != "undefined") {
      return h;
    }

    const height = this.getAttribute("height");
    if (typeof height != "undefined") {
      return height;
    }

    throw new Error(`Asked for height of asset ${this.id} which is not defined and no default was specified.`);
  }

  /**
   * @function imageElement
   * @memberof RezAsset
   * @param {number} w - optional width override
   * @param {number} h - optional height override
   * @returns {HTMLImageElement} an HTML image element configured for this asset
   * @description Creates an HTML image element for this asset with the specified or default dimensions
   */
  imageElement(w, h) {
    const el = document.createElement("img");
    el.setAttribute("src", this.$dist_path);
    el.setAttribute("width", this.getWidth(w));
    el.setAttribute("height", this.getHeight(h));
    return el;
  }

  /**
   * @function imageTag
   * @memberof RezAsset
   * @param {number} w - optional width override
   * @param {number} h - optional height override
   * @returns {string} HTML image tag as a string
   * @description Generates an HTML image tag string for this asset with specified or default dimensions
   */
  imageTag(w, h) {
    return this.imageElement(w, h).outerHTML;
  }

  /**
   * @function videoTag
   * @memberof RezAsset
   * @throws {Error} video tags are not yet implemented
   * @description Placeholder for generating HTML video tags (not yet implemented)
   */
  videoTag() {
    throw new Error(`Video tags not implemented |${this.id}|`);
  }
}

window.Rez.RezAsset = RezAsset;

//-----------------------------------------------------------------------------
// Behaviour
//-----------------------------------------------------------------------------

/**
 * @class RezBehaviour
 * @extends RezBasicObject
 * @description Represents a behaviour in the Rez game engine's behaviour tree system.
 * Behaviours are reusable templates that define game logic and can be instantiated with
 * specific options and child behaviours. They execute with working memory (wmem) and
 * return success/failure results.
 */
class RezBehaviour extends RezBasicObject {
  #options;
  #children;

  /**
   * @function constructor
   * @memberof RezBehaviour
   * @param {string} id - unique identifier for this behaviour
   * @param {object} attributes - behaviour attributes from Rez compilation
   * @description Creates a new behaviour template with empty options and children
   */
  constructor(id, attributes) {
    super("behaviour", id, attributes);

    this.#options = {};
    this.#children = [];
  }

  /**
   * @function firstChild
   * @memberof RezBehaviour
   * @returns {RezBehaviour|undefined} the first child behaviour or undefined if no children
   * @description Convenience accessor for the first child behaviour
   */
  get firstChild() {
    return this.#children[0];
  }

  /**
   * @function secondChild
   * @memberof RezBehaviour
   * @returns {RezBehaviour|undefined} the second child behaviour or undefined if fewer than 2 children
   * @description Convenience accessor for the second child behaviour
   */
  get secondChild() {
    return this.#children[1];
  }

  /**
   * @function childCount
   * @memberof RezBehaviour
   * @returns {number} the number of child behaviours
   * @description Returns the count of child behaviours attached to this behaviour
   */
  get childCount() {
    return this.#children.length;
  }

  /**
   * @function configure
   * @memberof RezBehaviour
   * @description Runs the behaviour's configuration function if defined.
   * This is called during instantiation to set up behaviour-specific configuration.
   */
  configure() {
    const config_fn = this.getAttribute("configure");
    if(typeof(config_fn) === "function") {
      config_fn(this);
    }
  }

  /**
   * @function option
   * @memberof RezBehaviour
   * @param {string} name - the option name to retrieve
   * @returns {*} the option value
   * @description Gets an option value by name
   * @throws {Error} if the option is not defined
   */
  option(name) {
    const value = this.#options[name];
    if(typeof(value) === "undefined") {
      throw new Error(`Behaviour ${this.id} does not define option '${name}'!`);
    }
    return value;
  }

  /**
   * @function numberOption
   * @memberof RezBehaviour
   * @param {string} name - the option name to retrieve
   * @returns {number} the option value as a number
   * @description Gets an option value and ensures it's a number
   * @throws {Error} if the option is not defined or not a number
   */
  numberOption(name) {
    const value = this.option(name);
    if(typeof(value) !== "number") {
      throw new Error(`Behaviour ${this.id} option '${name}' is not a number (${typeof(value)})!`);
    }
    return value;
  }

  /**
   * @function intOption
   * @memberof RezBehaviour
   * @param {string} name - the option name to retrieve
   * @returns {number} the option value as an integer
   * @description Gets an option value as an integer (floors any decimal values)
   */
  intOption(name) {
    return Math.floor(this.numberOption(name));
  }

  /**
   * @function setOption
   * @memberof RezBehaviour
   * @param {string} name - the option name to set
   * @param {*} value - the value to set
   * @description Sets an option value by name
   */
  setOption(name, value) {
    this.#options[name] = value;
  }

  /**
   * @function getChildAt
   * @memberof RezBehaviour
   * @param {number} idx - the index of the child to retrieve
   * @returns {RezBehaviour|undefined} the child behaviour at the specified index
   * @description Gets a child behaviour by index
   */
  getChildAt(idx) {
    return this.#children[idx];
  }


  /**
   * @function executeBehaviour
   * @memberof RezBehaviour
   * @returns {boolean} true if the behaviour succeeded, false otherwise
   * @description Executes this behaviour using the owner's blackboard for context.
   * @throws {Error} if the execute function returns an invalid result format
   */
  executeBehaviour() {
    const execute = this.getAttribute("execute");
    if(typeof(execute) !== "function") {
      console.error(`Behaviour ${this.id}: No execute handler found.`);
      return false;
    }

    const result = execute(this);
    if(typeof(result) !== "boolean") {
      throw new Error(`Behaviour ${this.id} execute returned non-boolean: ${typeof(result)}`);
    }

    return result;
  }

  /**
   * @function instantiate
   * @memberof RezBehaviour
   * @param {object} owner - the object that owns this behaviour instance
   * @param {object} options - options to configure this behaviour instance
   * @param {RezBehaviour[]} children - child behaviours for this instance
   * @returns {RezBehaviour} a new configured behaviour instance
   * @description Creates a new instance of this behaviour template with the specified owner,
   * options, and children. The instance is configured after creation.
   */
  instantiate(owner, options, children = []) {
    const behaviour = this.copyWithAutoId();
    behaviour.owner = owner;
    behaviour.options = options;
    behaviour.children = children;
    behaviour.configure();
    return behaviour;
  }
}

window.Rez.RezBehaviour = RezBehaviour;

//-----------------------------------------------------------------------------
// Card
//-----------------------------------------------------------------------------

class RezCard extends RezBasicObject {
  #currentBlock;

  constructor(id, attributes) {
    super("card", id, attributes);
    this.#currentBlock = null;
  }

  get currentBlock() {
    return this.#currentBlock;
  }

  set currentBlock(block) {
    this.#currentBlock = block;
  }

  targetType = "card";

  bindAs() {
    return "card";
  }

  getViewTemplate(flipped) {
    return flipped ? (this.$flipped_template || this.$content_template) : this.$content_template;
  }

  handleCustomEvent(event_name, evt) {
    const handler = this.eventHandler(event_name);
    if(handler && typeof handler == "function") {
      return handler(this, evt);
    } else {
      return {
        error: `No handler for event ${event_name}. Did you use an on_xxx prefix?`,
      };
    }
  }
}

window.Rez.RezCard = RezCard;

//-----------------------------------------------------------------------------
// Decision
//-----------------------------------------------------------------------------

/**
 * @class RezDecision
 * @description Represents a decision that can be made by user-written filters in the Rez game engine.
 * This is a simplified abstraction of RezDynamicLink that allows code to make yes/no decisions
 * with optional reasons and data. Decisions can be made explicitly or use default values.
 * 
 * @example
 * // Create a decision and make a choice
 * const decision = new RezDecision("Filter Item");
 * if(item.isAllowed) {
 *   decision.yes();
 * } else {
 *   decision.no("Item not permitted");
 * }
 */
class RezDecision {
  #purpose;
  #made;
  #result;
  #hidden;
  #reason;
  #data;
  #used_default;

  /**
   * @function constructor
   * @memberof RezDecision
   * @param {string} purpose - description of what this decision is for
   * @param {object} data - optional data object to associate with this decision
   * @description Creates a new decision with the specified purpose and optional data
   */
  constructor(purpose, data = {}) {
    this.#purpose = purpose;
    this.#made = false;
    this.#result = false;
    this.#hidden = false;
    this.#reason = "";
    this.#data = data;
    this.#used_default = false;
  }

  /**
   * @function purpose
   * @memberof RezDecision
   * @returns {string} the purpose or description of this decision
   * @description Returns the purpose string that describes what this decision is about
   */
  get purpose() {
    return this.#purpose;
  }

  /**
   * @function wasMade
   * @memberof RezDecision
   * @returns {boolean} true if a decision has been made
   * @description Indicates whether any decision method (yes, no, hide, or default variants) has been called
   */
  get wasMade() {
    return this.#made;
  }

  /**
   * @function result
   * @memberof RezDecision
   * @returns {boolean} the boolean result of the decision
   * @description Returns true for yes decisions, false for no decisions
   */
  get result() {
    return this.#result;
  }

  /**
   * @function wasYes
   * @memberof RezDecision
   * @returns {boolean} true if the decision was yes
   * @description Convenience method that returns true if the decision result was positive
   */
  get wasYes() {
    return this.#result;
  }

  /**
   * @function wasNo
   * @memberof RezDecision
   * @returns {boolean} true if the decision was no
   * @description Convenience method that returns true if the decision result was negative
   */
  get wasNo() {
    return !this.wasYes;
  }

  /**
   * @function isHidden
   * @memberof RezDecision
   * @returns {boolean} true if this decision should be hidden from the user
   * @description Indicates whether this decision was made with the hide() method
   */
  get isHidden() {
    return this.#hidden;
  }

  /**
   * @function reason
   * @memberof RezDecision
   * @returns {string} the reason provided for negative decisions
   * @description Returns the reason string provided when making a no decision
   */
  get reason() {
    return this.#reason;
  }

  /**
   * @function data
   * @memberof RezDecision
   * @returns {object} the data object associated with this decision
   * @description Returns the data object that was passed to the constructor or added via setData
   */
  get data() {
    return this.#data;
  }

  /**
   * @function usedDefault
   * @memberof RezDecision
   * @returns {boolean} true if a default decision method was used
   * @description Indicates whether this decision was made using defaultYes() or defaultNo()
   */
  get usedDefault() {
    return this.#used_default;
  }

  /**
   * @function yes
   * @memberof RezDecision
   * @returns {RezDecision} this decision instance for method chaining
   * @description Makes a positive decision explicitly
   */
  yes() {
    this.#made = true;
    this.#result = true;
    this.#used_default = false;
    return this;
  }

  /**
   * @function defaultYes
   * @memberof RezDecision
   * @returns {RezDecision} this decision instance for method chaining
   * @description Makes a positive decision using the default value (indicates no explicit choice was made)
   */
  defaultYes() {
    this.#made = true;
    this.#result = true;
    this.#used_default = true;
    return this;
  }

  /**
   * @function no
   * @memberof RezDecision
   * @param {string} reason - optional reason for the negative decision
   * @returns {RezDecision} this decision instance for method chaining
   * @description Makes a negative decision explicitly with an optional reason
   */
  no(reason = "none given") {
    this.#made = true;
    this.#result = false;
    this.#reason = reason;
    this.#used_default = false;
    return this;
  }

  /**
   * @function hide
   * @memberof RezDecision
   * @description Makes a negative decision that should be hidden from the user.
   * Sets the decision as made, result to false, reason to "hidden", and marks it as hidden.
   */
  hide() {
    this.#made = true;
    this.#result = false;
    this.#reason = "hidden";
    this.#hidden = true;
    this.#used_default = false;
  }

  /**
   * @function defaultNo
   * @memberof RezDecision
   * @param {string} reason - optional reason for the negative decision
   * @returns {RezDecision} this decision instance for method chaining
   * @description Makes a negative decision using the default value with an optional reason
   */
  defaultNo(reason = "none given") {
    this.#made = true;
    this.#result = false;
    this.#reason = reason;
    this.#used_default = true;
    return this;
  }

  /**
   * @function setData
   * @memberof RezDecision
   * @param {string} key - the data key to set
   * @param {*} value - the value to associate with the key
   * @returns {RezDecision} this decision instance for method chaining
   * @description Sets a key-value pair in the decision's data object
   */
  setData(key, value) {
    this.#data[key] = value;
    return this;
  }

  /**
   * @function explain
   * @memberof RezDecision
   * @returns {string} a human-readable explanation of the decision
   * @description Returns a descriptive string explaining the decision result, reason, and visibility
   */
  explain() {
    if (this.result) {
      return `Result was yes`;
    } else {
      if (this.hidden) {
        return `Result was no (${this.reason}) and hide the decision`;
      } else {
        return `Result was no (${this.reason})`;
      }
    }
  }
}

//-----------------------------------------------------------------------------
// Dice
//-----------------------------------------------------------------------------

class RezDie {
  #sides;

  constructor(sides = 6) {
    this.#sides = sides;
  }

  get sides() {
    return this.#sides;
  }

  roll() {
    return Math.rand_int_between(1, this.sides);
  }

  open_roll() {
    let roll, total = 0;

    do {
      roll = this.roll();
      total += roll;
    } while(roll == this.sides);

    return total;
  }
}

window.Rez.RezDie = RezDie;

class RezDieRoll {
  #die;
  #count;
  #modifier;
  #rounds;
  #exploding;
  #advantage;
  #disadvantage;

  constructor(count, sides = 6, modifier = 0, rounds = 1) {
    this.#die = new RezDie(sides);
    this.#count = count;
    this.#modifier = modifier;
    this.#rounds = rounds;
    this.#exploding = false;
    this.#advantage = false;
    this.#disadvantage = false;
  }

  get count() {
    return this.#count;
  }

  get die() {
    return this.#die;
  }

  get sides() {
    return this.#die.sides;
  }

  get modifier() {
    return this.#modifier;
  }

  get rounds() {
    return this.#rounds;
  }

  set exploding(exploding) {
    this.#exploding = exploding;
    if(exploding) {
      this.#advantage = false;
      this.#disadvantage = false;
    }
    return this;
  }

  set advantage(advantage) {
    this.#advantage = advantage;
    if(advantage) {
      this.#exploding = false;
      this.#disadvantage = false;
    }
    return this;
  }

  set disadvantage(disadvantage) {
    this.#disadvantage = disadvantage;
    if(disadvantage) {
      this.#exploding = false;
      this.#advantage = false;
    }
    return this;
  }

  copy() {
    const die = new RezDieRoll(this.count, this.sides, this.modifier, this.rounds);
    die.#exploding = this.#exploding;
    die.#advantage = this.#advantage;
    die.#disadvantage = this.#disadvantage;
    return die;
  }

  rollDice() {
    let sum = this.modifier;
    for (let i = 0; i < this.count; i++) {
      if(this.#exploding) {
        sum += this.die.open_roll();
      } else {
        sum += this.die.roll();
      }

    }
    return sum;
  }

  rollWithAdvantage() {
    return [this.rollDice(), this.rollDice()].max();
  }

  rollWithDisadvange() {
    return [this.rollDice(), this.rollDice()].min();
  }

  rollRound() {
    if(this.#advantage) {
      return this.rollWithAdvantage();
    } else if(this.#disadvantage) {
      return this.rollWithDisadvange();
    } else {
      return this.rollDice();
    }
  }

  roll() {
    if(this.rounds == 1) {
      return this.rollRound();
    } else {
      const sum = Math.range(1, this.rounds)
        .map(() => this.rollRound())
        .reduce((sum, round) => sum + round, 0);
      return sum.cl_avg(this.rounds);
    }
  }

  description() {
    return `${this.desc_count()}d${this.die.sides}${this.desc_mod()}`;
  }

  desc_count() {
    if(this.count > 0) {
      return `${this.count}`;
    } else {
      return "";
    }
  }

  desc_mod() {
    if(this.modifier < 0) {
      return `${this.modifier}`;
    } else if(this.modifier > 0) {
      return `+${this.modifier}`;
    } else {
      return "";
    }
  }
}

window.Rez.RezDieRoll = RezDieRoll;

window.Rez.makeDie = function(diceStr) {
  const regex = /^(\d+)?d(\d+)([\+\-]\d+)?([!ad])?$/i;
  const match = diceStr.match(regex);

  if (!match) {
    throw new Error('Invalid dice format');
  }

  const [_, count = '1', sides, modifier = '0', special] = match;
  const numDice = parseInt(count);
  const numSides = parseInt(sides);
  const mod = parseInt(modifier);

  const die = new RezDieRoll(numDice, numSides, mod);

  if(special === "a") {
    die.advantage = true;
  } else if(special === "d") {
    die.disadvantage = true;
  } else if(special === "!") {
    die.exploding = true
  };

  return die;
}

window.Rez.D4 = Rez.makeDie("d4");
window.Rez.rollD4 = () => window.Rez.D4.roll();
window.Rez.D6 = Rez.makeDie("d6");
window.Rez.rollD6 = () => window.Rez.D6.roll();
window.Rez.D8 = Rez.makeDie("d8");
window.Rez.rollD8 = () => window.Rez.D8.roll();
window.Rez.D10 = Rez.makeDie("d10");
window.Rez.rollD10 = () => window.Rez.D10.roll();
window.Rez.D12 = Rez.makeDie("d12");
window.Rez.rollD12 = () => window.Rez.D12.roll();
window.Rez.D20 = Rez.makeDie("d20");
window.Rez.rollD20 = () => window.Rez.D20.roll();
window.Rez.D100 = Rez.makeDie("d100");
window.Rez.rollD100 = () => window.Rez.D100.roll();

//-----------------------------------------------------------------------------
// DynamicLink
//-----------------------------------------------------------------------------

class RezDynamicLink {
  #card;
  #inactiveClass;
  #choosen;
  #display;
  #markup;

  constructor(card) {
    this.#card = card;
    this.#inactiveClass = "inactive";
    this.#choosen = false;
    this.#display = true;
    this.#markup = "<strong>No text for dynamic link</strong>";
  }

  get card() {
    return this.#card;
  }

  get inactiveClass() {
    return this.#inactiveClass;
  }

  get choosen() {
    return this.#choosen;
  }

  get display() {
    return this.#display;
  }

  get markup() {
    return this.#markup;
  }

  allow(response, targetId) {
    this.#choosen = true;
    if (typeof response === "function") {
      this.#markup = response();
    } else {
      this.#markup = `<a href="javascript:void(0)" data-event="card" data-target="${targetId}">${response}</a>`;
    }
  }

  deny(text, asLink) {
    this.#choosen = true;

    if(asLink == null || asLink) {
      this.#markup = `<a href="javascript:void(0)" class="${this.inactiveClass}">${text}</a>`;
    } else {
      this.#markup = `<span class="${this.inactiveClass}">${text}</span>`;
    }
  }

  hide() {
    this.#choosen = true;
    this.#display = false;
  }
}

window.Rez.RezDynamicLink = RezDynamicLink;

//-----------------------------------------------------------------------------
// Effect
//-----------------------------------------------------------------------------

/**
 * @class RezEffect
 * @extends RezBasicObject
 * @description Represents an effect in the Rez game engine. Effects are typically
 * applied to or removed from objects when items are equipped, consumed, or used.
 * They can modify object attributes, add temporary abilities, or trigger events.
 */
class RezEffect extends RezBasicObject {
  /**
   * @function constructor
   * @memberof RezEffect
   * @param {string} id - unique identifier for this effect
   * @param {object} attributes - effect attributes from Rez compilation
   * @description Creates a new effect instance
   */
  constructor(id, attributes) {
    super("effect", id, attributes);
  }

  /**
   * @function apply
   * @memberof RezEffect
   * @param {string} ownerId - ID of the object this effect is being applied to
   * @param {string} slotId - ID of the inventory slot where the item is located
   * @param {string} itemId - ID of the item that has this effect
   * @returns {*} result of the apply event handler
   * @description Applies this effect to the specified object by running the apply event handler
   */
  apply(ownerId, slotId, itemId) {
    return this.runEvent("apply", {owner_id: ownerId, slot_id: slotId, item_id: itemId});
  }

  /**
   * @function remove
   * @memberof RezEffect
   * @param {string} ownerId - ID of the object this effect is being removed from
   * @param {string} slotId - ID of the inventory slot where the item is located
   * @param {string} itemId - ID of the item that has this effect
   * @returns {*} result of the remove event handler
   * @description Removes this effect from the specified object by running the remove event handler
   */
  remove(ownerId, slotId, itemId) {
    return this.runEvent("remove", {owner_id: ownerId, slot_id: slotId, item_id: itemId});
  }
}

window.Rez.RezEffect = RezEffect;

//-----------------------------------------------------------------------------
// Event Handling SubSystem
//-----------------------------------------------------------------------------

/**
 * @class RezEvent
 * @description Represents a game event response in the Rez game engine. Events are used to communicate
 * the results of user interactions and specify what actions should be taken (scene changes, card plays,
 * flash messages, etc.). Supports method chaining for building complex event responses.
 * 
 * @example
 * // Create an event that plays a card and shows a message
 * return RezEvent.playCard("next_card").flash("Moving forward!").render();
 */
class RezEvent {
  #params;
  #flashMessages;
  #cardId;
  #sceneId;
  #sceneChangeEvent;
  #sceneInterludeEvent;
  #sceneResumeEvent;
  #renderEvent;
  #errorMessage;

  /**
   * @function constructor
   * @memberof RezEvent
   * @description Creates a new event response with default values
   */
  constructor() {
    this.#params = {};
    this.#flashMessages = [];
    this.#cardId = null;
    this.#sceneId = null;
    this.#sceneChangeEvent = false;
    this.#sceneInterludeEvent = false;
    this.#sceneResumeEvent = false;
    this.#renderEvent = false;
    this.#errorMessage = null;
  }

  /**
   * @function params
   * @memberof RezEvent
   * @returns {object} the parameters object associated with this event
   */
  get params() {
    return this.#params;
  }

  /**
   * @function flashMessages
   * @memberof RezEvent
   * @returns {string[]} array of flash messages to display
   */
  get flashMessages() {
    return this.#flashMessages;
  }

  /**
   * @function cardId
   * @memberof RezEvent
   * @returns {string|null} ID of the card to play, or null if no card action
   */
  get cardId() {
    return this.#cardId;
  }

  /**
   * @function sceneId
   * @memberof RezEvent
   * @returns {string|null} ID of the scene for scene transition, or null if no scene action
   */
  get sceneId() {
    return this.#sceneId;
  }

  /**
   * @function sceneChangeEvent
   * @memberof RezEvent
   * @returns {boolean} true if this event should trigger a scene change
   */
  get sceneChangeEvent() {
    return this.#sceneChangeEvent;
  }

  /**
   * @function sceneInterludeEvent
   * @memberof RezEvent
   * @returns {boolean} true if this event should trigger a scene interlude
   */
  get sceneInterludeEvent() {
    return this.#sceneInterludeEvent;
  }

  /**
   * @function sceneResumeEvent
   * @memberof RezEvent
   * @returns {boolean} true if this event should resume the previous scene
   */
  get sceneResumeEvent() {
    return this.#sceneResumeEvent;
  }

  /**
   * @function renderEvent
   * @memberof RezEvent
   * @returns {boolean} true if this event should trigger a view render
   */
  get renderEvent() {
    return this.#renderEvent;
  }

  /**
   * @function errorMessage
   * @memberof RezEvent
   * @returns {string|null} error message if this is an error event, or null
   */
  get errorMessage() {
    return this.#errorMessage;
  }

  /**
   * @function setParam
   * @memberof RezEvent
   * @param {string} name - parameter name
   * @param {*} value - parameter value
   * @returns {RezEvent} this event for method chaining
   * @description Sets a single parameter on this event
   */
  setParam(name, value ) {
    this.#params[name] = value;
    return this;
  }

  /**
   * @function setParams
   * @memberof RezEvent
   * @param {object} params - parameters object to set
   * @returns {RezEvent} this event for method chaining
   * @description Replaces the entire parameters object for this event
   */
  setParams(params) {
    this.#params = params;
    return this;
  }

  /**
   * @function hasFlash
   * @memberof RezEvent
   * @returns {boolean} true if this event has flash messages to display
   */
  get hasFlash() {
    return this.#flashMessages.length > 0;
  }

  /**
   * @function flash
   * @memberof RezEvent
   * @param {string} message - message to display as a flash
   * @returns {RezEvent} this event for method chaining
   * @description Adds a flash message to be displayed to the user
   */
  flash(message) {
    this.#flashMessages.push(message);
    return this;
  }

  /**
   * @function shouldPlayCard
   * @memberof RezEvent
   * @returns {boolean} true if this event should play a card
   */
  get shouldPlayCard() {
    return this.#cardId != null;
  }

  /**
   * @function playCard
   * @memberof RezEvent
   * @param {string} cardId - ID of the card to play
   * @returns {RezEvent} this event for method chaining
   * @description Sets this event to play the specified card
   */
  playCard(cardId) {
    this.#cardId = cardId;
    return this;
  }

  /**
   * @function shouldRender
   * @memberof RezEvent
   * @returns {boolean} true if this event should trigger a view render
   */
  get shouldRender() {
    return this.#renderEvent;
  }

  /**
   * @function render
   * @memberof RezEvent
   * @returns {RezEvent} this event for method chaining
   * @description Sets this event to trigger a view render
   */
  render() {
    this.#renderEvent = true;
    return this;
  }

  /**
   * @function shouldChangeScene
   * @memberof RezEvent
   * @returns {boolean} true if this event should change to a new scene
   */
  get shouldChangeScene() {
    return this.#sceneChangeEvent;
  }

  /**
   * @function sceneChange
   * @memberof RezEvent
   * @param {string} sceneId - ID of the scene to change to
   * @returns {RezEvent} this event for method chaining
   * @description Sets this event to change to the specified scene
   */
  sceneChange(sceneId) {
    this.#sceneChangeEvent = true;
    this.#sceneId = sceneId;
    return this;
  }

  /**
   * @function shouldInterludeScene
   * @memberof RezEvent
   * @returns {boolean} true if this event should start a scene interlude
   */
  get shouldInterludeScene() {
    return this.#sceneInterludeEvent;
  }

  /**
   * @function sceneInterlude
   * @memberof RezEvent
   * @param {string} sceneId - ID of the scene to interlude with
   * @returns {RezEvent} this event for method chaining
   * @description Sets this event to start an interlude with the specified scene
   */
  sceneInterlude(sceneId) {
    this.#sceneInterludeEvent = true;
    this.#sceneId = sceneId;
    return this;
  }

  /**
   * @function shouldResumeScene
   * @memberof RezEvent
   * @returns {boolean} true if this event should resume the previous scene
   */
  get shouldResumeScene() {
    return this.#sceneResumeEvent;
  }

  /**
   * @function sceneResume
   * @memberof RezEvent
   * @returns {RezEvent} this event for method chaining
   * @description Sets this event to resume the previous scene from the scene stack
   */
  sceneResume() {
    this.#sceneResumeEvent = true;
    return this;
  }

  /**
   * @function isError
   * @memberof RezEvent
   * @returns {boolean} true if this is an error event
   */
  get isError() {
    return this.#errorMessage != null;
  }

  /**
   * @function error
   * @memberof RezEvent
   * @param {string} message - error message
   * @returns {RezEvent} this event for method chaining
   * @description Sets this event as an error with the specified message
   */
  error(message) {
    this.#errorMessage = message;
    return this;
  }

  /**
   * @function noop
   * @memberof RezEvent
   * @returns {RezEvent} this event for method chaining
   * @description No-operation method for method chaining when no action is needed
   */
  noop() {
    return this;
  }

  /**
   * @function built_in
   * @memberof RezEvent
   * @static
   * @returns {RezEvent} a new empty event
   * @description Creates a new built-in event with default values
   */
  static built_in() {
    return new RezEvent();
  }

  /**
   * @function flash
   * @memberof RezEvent
   * @static
   * @param {string} message - flash message to display
   * @returns {RezEvent} a new event with the flash message
   * @description Creates a new event that displays a flash message
   */
  static flash(message) {
    return new RezEvent().flash(message);
  }

  /**
   * @function playCard
   * @memberof RezEvent
   * @static
   * @param {string} cardId - ID of the card to play
   * @returns {RezEvent} a new event that plays the specified card
   * @description Creates a new event that plays the specified card
   */
  static playCard(cardId) {
    return new RezEvent().playCard(cardId);
  }

  /**
   * @function render
   * @memberof RezEvent
   * @static
   * @returns {RezEvent} a new event that triggers a render
   * @description Creates a new event that triggers a view render
   */
  static render() {
    return new RezEvent().render();
  }

  /**
   * @function setParam
   * @memberof RezEvent
   * @static
   * @param {string} param - parameter name
   * @param {*} value - parameter value
   * @returns {RezEvent} a new event with the specified parameter
   * @description Creates a new event with a single parameter set
   */
  static setParam(param, value) {
    return new RezEvent().setParam(param, value);
  }

  /**
   * @function sceneChange
   * @memberof RezEvent
   * @static
   * @param {string} sceneId - ID of the scene to change to
   * @returns {RezEvent} a new event that changes to the specified scene
   * @description Creates a new event that changes to the specified scene
   */
  static sceneChange(sceneId) {
    return new RezEvent().sceneChange(sceneId);
  }

  /**
   * @function sceneInterlude
   * @memberof RezEvent
   * @static
   * @param {string} sceneId - ID of the scene to interlude with
   * @returns {RezEvent} a new event that starts an interlude
   * @description Creates a new event that starts an interlude with the specified scene
   */
  static sceneInterlude(sceneId) {
    return new RezEvent().sceneInterlude(sceneId);
  }

  /**
   * @function sceneResume
   * @memberof RezEvent
   * @static
   * @returns {RezEvent} a new event that resumes the previous scene
   * @description Creates a new event that resumes the previous scene from the stack
   */
  static sceneResume() {
    return new RezEvent().sceneResume();
  }

  /**
   * @function noop
   * @memberof RezEvent
   * @static
   * @returns {RezEvent} a new empty event
   * @description Creates a new event that performs no action
   */
  static noop() {
    return new RezEvent();
  }

  /**
   * @function error
   * @memberof RezEvent
   * @static
   * @param {string} message - error message
   * @returns {RezEvent} a new error event
   * @description Creates a new event that represents an error
   */
  static error(message) {
    return new RezEvent().error(message);
  }
}

window.Rez.RezEvent = RezEvent;

/**
 * @class RezEventProcessor
 * @description Processes events in the Rez game engine. Handles browser events (clicks, inputs, submits),
 * custom game events, timer events, and system events. Routes events to appropriate handlers and manages
 * the event lifecycle including system pre/post processing and undo manager integration.
 */
class RezEventProcessor {
  #game;

  /**
   * @function constructor
   * @memberof RezEventProcessor
   * @param {RezGame} game - the game instance this processor belongs to
   * @description Creates a new event processor for the specified game
   */
  constructor(game) {
    this.#game = game;
  }

  /**
   * @function game
   * @memberof RezEventProcessor
   * @returns {RezGame} the game instance
   */
  get game() {
    return this.#game;
  }

  /**
   * @function scene
   * @memberof RezEventProcessor
   * @returns {RezScene} the current scene
   */
  get scene() {
    return this.#game.current_scene;
  }

  /**
   * @function card
   * @memberof RezEventProcessor
   * @returns {RezCard} the current card
   */
  get card() {
    return this.#game.current_scene.current_card;
  }

  /**
   * @function dispatchResponse
   * @memberof RezEventProcessor
   * @param {RezEvent} response - the event response to process
   * @description Processes a RezEvent response by executing the actions it specifies:
   * flash messages, scene changes/interludes/resumes, card plays, view renders, and error handling.
   * @throws {Error} if the response is not a RezEvent instance
   */
  dispatchResponse(response) {
    if(response instanceof RezEvent) {
      if(response.hasFlash) {
        for(let message of response.flashMessages) {
          this.game.addFlashMessage(message);
        }
      }

      if(response.shouldChangeScene) {
        this.game.startSceneWithId(response.sceneId, response.params);
      } else if(response.shouldInterludeScene) {
        this.game.interludeSceneWithId(response.sceneId, response.params);
      } else if(response.shouldResumeScene) {
        this.game.resumePrevScene();
      }

      if(response.shouldPlayCard) {
        this.scene.playCardWithId(response.cardId, response.params);
      }

      if(response.shouldRender) {
        this.game.updateView();
      }

      if(response.isError) {
        console.log(`Error: ${response.errorMessage}`);
      }
    } else {
      throw new Error("Event handlers must return a RezEvent object!");
    }
  }

  /**
   * @function beforeEventProcessing
   * @memberof RezEventProcessor
   * @param {Event} evt - the browser event to pre-process
   * @returns {Event} the processed event
   * @description Runs the event through all enabled systems' before_event handlers.
   * Each system can modify the event before it gets processed.
   * @throws {Error} if any system handler doesn't return a valid event object
   */
  beforeEventProcessing(evt) {
    const systems = this.game.getEnabledSystems();

    return systems.reduce((eventInProgress, system) => {
      const handler = system.before_event;
      const handledEvent = handler ? handler(system, eventInProgress) : eventInProgress;
      if(typeof(handledEvent) === "undefined") {
        throw new Error(`before_event handler of system |${system.id}| has not returned a valid evt object!`);
      }
      return handledEvent;
    }, evt);
  }

  /**
   * @function afterEventProcessing
   * @memberof RezEventProcessor
   * @param {Event} evt - the original browser event
   * @param {*} result - the result from event processing
   * @returns {*} the processed result
   * @description Runs the event result through all enabled systems' after_event handlers.
   * Each system can modify the result after the event has been processed.
   * @throws {Error} if any system handler doesn't return a valid result object
   */
  afterEventProcessing(evt, result) {
    const systems = this.game.getEnabledSystems();

    return systems.reduce((intermediateResult, system) => {
      const handler = system.after_event;
      const handledResult = handler ? handler(system, evt, intermediateResult) : intermediateResult;
      if(typeof(handledResult) === "undefined") {
        throw new Error(`after_event handler of system |${system.id}| has not returned a valid result object!`);
      }
      return handledResult;
    }, result);
  }

  /**
   * @function raiseTimerEvent
   * @memberof RezEventProcessor
   * @param {RezTimer} timer - the timer that fired
   * @returns {*} the result of processing the timer event
   * @description Creates and processes a custom timer event
   */
  raiseTimerEvent(timer) {
    const evt = new CustomEvent('timer', {detail: {timer: timer}});
    return this.handleBrowserEvent(evt);
  }

  /**
   * @function raiseKeyBindingEvent
   * @memberof RezEventProcessor
   * @param {string} event_name - the name of the key binding event
   * @returns {*} the result of processing the key binding event
   * @description Creates and processes a custom key binding event
   */
  raiseKeyBindingEvent(event_name) {
    const evt = new CustomEvent("key_binding", {detail: {event_name: event_name}});
    return this.handleBrowserEvent(evt);
  }

  /**
   * @function isAutoUndoEvent
   * @memberof RezEventProcessor
   * @param {Event} evt - the event to check
   * @returns {boolean} true if this event type should trigger automatic undo recording
   * @description Determines if an event should automatically record undo state
   */
  isAutoUndoEvent(evt) {
    const evtTypes = ["click", "input", "submit", "key_binding"];
    return evtTypes.includes(evt.type);
  }

  /**
   * @function handleBrowserEvent
   * @memberof RezEventProcessor
   * @param {Event} evt - the browser event to handle
   * @returns {*} the result of processing the event
   * @description Main event handler that processes browser events. Handles undo recording,
   * system pre/post processing, and routes events to specific handlers based on type.
   */
  handleBrowserEvent(evt) {
    console.log("HandleBrowserEvent");

    if(this.isAutoUndoEvent(evt)) {
      this.game.undoManager.startChange();
      this.game.undoManager.recordViewChange(this.game.view.copy());
    }

    evt = this.beforeEventProcessing(evt);

    let result;

    if (evt.type === "click") {
      result = this.handleBrowserClickEvent(evt);
    } else if (evt.type === "input") {
      result = this.handleBrowserInputEvent(evt);
    } else if (evt.type === "submit") {
      result = this.handleBrowserSubmitEvent(evt);
    } else if(evt.type === "timer") {
      result = this.handleTimerEvent(evt);
    } else if(evt.type === "key_binding") {
      result = this.handleKeyBindingEvent(evt);
    } else {
      result = {unhandled: true};
    }

    return this.afterEventProcessing(evt, result);
  }

  /**
   * @function decodeEvent
   * @memberof RezEventProcessor
   * @param {Event} evt - the browser event to decode
   * @returns {Array} [eventName, target, params] decoded from the event's dataset
   * @description Extracts event name, target, and parameters from an element's dataset attributes
   */
  decodeEvent(evt) {
    const { event, target, ...params } = evt.currentTarget.dataset;
    return [event.toLowerCase(), target, params];
  }

  /**
   * @function handleTimerEvent
   * @memberof RezEventProcessor
   * @param {CustomEvent} evt - the timer event with timer details
   * @returns {*} the result of handling the timer event
   * @description Handles timer events by routing them to custom event handlers
   */
  handleTimerEvent(evt) {
    const timer = evt.detail.timer;
    const result = this.handleCustomEvent(timer.event, {timer: timer.id});
    if(!typeof(result) === "object") {
      return {handled: true}
    } else {
      return result;
    }
  }

  /**
   * @function handleKeyBindingEvent
   * @memberof RezEventProcessor
   * @param {CustomEvent} evt - the key binding event with event name details
   * @returns {*} the result of handling the key binding event
   * @description Handles key binding events by routing them to custom event handlers
   */
  handleKeyBindingEvent(evt) {
    const result = this.handleCustomEvent(evt.detail.event_name, {});
    if(!typeof(result) === "object") {
      return {handled: true}
    } else {
      return result;
    }
  }

  /**
   * @function handleBrowserClickEvent
   * @memberof RezEventProcessor
   * @param {Event} evt - the click event
   * @returns {*} the result of handling the click event
   * @description Handles browser click events by decoding the event data and routing to appropriate handlers.
   * Supports built-in event types (card, switch, interlude, resume) and custom events.
   */
  handleBrowserClickEvent(evt) {
    const [eventName, target, params] = this.decodeEvent(evt);

    if(typeof(eventName) === "undefined") {
      console.log("Received click event without an event name!");
      return false;
    }

    if (eventName === "card") {
      return this.handleCardEvent(target, params);
    } else if (eventName === "switch") {
      return this.handleSwitchEvent(target, params);
    } else if (eventName === "interlude") {
      return this.handleInterludeEvent(target, params);
    } else if (eventName === "resume") {
      return this.handleResumeEvent(params);
    } else {
      return this.handleCustomEvent(eventName, params);
    }
  }

  /**
   * @function getReceiverEventHandler
   * @memberof RezEventProcessor
   * @param {*} receiver - the object to check for event handlers
   * @param {string} eventname - the name of the event to find a handler for
   * @returns {Function|null} the event handler function or null if not found
   * @description Gets an event handler function from a receiver object
   */
  getReceiverEventHandler(receiver, eventname) {
    let handler = receiver.eventHandler(eventname);
    if(handler && typeof(handler) === "function") {
      return handler;
    } else {
      return null;
    }
  }

  /**
   * @function getEventHandler
   * @memberof RezEventProcessor
   * @param {string} eventName - the name of the event to find a handler for
   * @returns {Array} [receiver, handler] pair where receiver is the object that handles the event
   * @description Finds an event handler by checking card, scene, and game in that order.
   * Returns the first receiver that has a handler for the event.
   */
  getEventHandler(eventName) {
    const receivers = [this.card, this.scene, this.game];
    const handlers = receivers.map((receiver) => [receiver, this.getReceiverEventHandler(receiver, eventName)]);
    return handlers.find(([receiver, handler]) => handler) ?? [null, null];
  }

  /**
   * @function handleCustomEvent
   * @memberof RezEventProcessor
   * @param {string} eventName - the name of the custom event
   * @param {object} params - parameters to pass to the event handler
   * @returns {RezEvent} the result of the event handler or an error event
   * @description Handles custom events by finding and calling the appropriate event handler
   */
  handleCustomEvent(eventName, params) {
    const [receiver, handler] = this.getEventHandler(eventName);
    if(!handler) {
      return RezEvent.error(`Unable to find an event handler for |${eventName}|`);
    } else {
      console.log(`Routing event |${eventName}| to |${receiver.id}|`);
      return handler(receiver, params);
    }
  }

  /**
   * @function handleCardEvent
   * @memberof RezEventProcessor
   * @param {string} target - ID of the card to play
   * @param {object} params - parameters to pass to the card
   * @returns {RezEvent} event that plays the specified card
   * @description Handles built-in card events that play a specific card
   */
  handleCardEvent(target, params) {
    console.log(`Handle card event: |${target}|`);
    return RezEvent.playCard(target).setParams(params);
  }

  /**
   * @function handleSwitchEvent
   * @memberof RezEventProcessor
   * @param {string} target - ID of the scene to switch to
   * @param {object} params - parameters to pass to the scene
   * @returns {RezEvent} event that changes to the specified scene
   * @description Handles built-in switch events that change to a new scene
   */
  handleSwitchEvent(target, params) {
    console.log(`Handle switch event: |${target}|`);
    return RezEvent.sceneChange(target).setParams(params);
  }

  /**
   * @function handleInterludeEvent
   * @memberof RezEventProcessor
   * @param {string} target - ID of the scene to interlude with
   * @param {object} params - parameters to pass to the scene
   * @returns {RezEvent} event that starts an interlude with the specified scene
   * @description Handles built-in interlude events that interrupt the current scene
   */
  handleInterludeEvent(target, params) {
    console.log(`Handle interlude event: |${target}|`);
    return RezEvent.sceneInterlude(target).setParams(params);
  }

  /**
   * @function handleResumeEvent
   * @memberof RezEventProcessor
   * @param {object} params - parameters to pass to the resumed scene
   * @returns {RezEvent} event that resumes the previous scene
   * @description Handles built-in resume events that return to the previous scene
   */
  handleResumeEvent(params) {
    console.log("Handle resume event");
    return RezEvent.sceneResume().setParams(params);
  }

  /**
   * @function handleBrowserInputEvent
   * @memberof RezEventProcessor
   * @param {Event} evt - the input event
   * @returns {RezEvent} the result of the card's input event handler
   * @description Handles browser input events by finding the card that contains the input element
   * and calling its input event handler.
   * @throws {Error} if the card container or card ID cannot be found
   */
  handleBrowserInputEvent(evt) {
    console.log("Handle input event");
    const card_div = evt.target.closest("div.rez-active-card div[data-card]");
    if(!card_div) {
      throw new Error(`Cannot find div for input |${evt.target.id}|`);
    }

    const cardId = card_div.dataset.card;
    if(!cardId) {
      throw new Error(`Cannot get card id for input |${evt.target.id}|`);
    }

    const card = $(cardId);
    return card.runEvent("input", { evt: evt }) || RezEvent.noop();
  }

  /**
   * @function handleBrowserSubmitEvent
   * @memberof RezEventProcessor
   * @param {Event} evt - the submit event
   * @returns {RezEvent} the result of the card's form event handler
   * @description Handles browser form submit events by finding the card that contains the form
   * and calling its event handler named after the form.
   * @throws {Error} if the form name or card container cannot be found
   */
  handleBrowserSubmitEvent(evt) {
    console.log("Handle submit event");

    const formName = evt.target.getAttribute("name");
    if (!formName) {
      throw new Error("Cannot get form name!");
    }

    const cardDiv = evt.target.closest("div.rez-active-card div[data-card]");
    if (!cardDiv) {
      throw new Error(`Cannot find div for form: |${formName}|`);
    }

    const cardId = cardDiv.dataset.card;
    const card = $(cardId);

    return card.runEvent(formName, { form: evt.target }) || RezEvent.noop();
  }
}

window.Rez.RezEventProcessor = RezEventProcessor;

//-----------------------------------------------------------------------------
// Faction
//-----------------------------------------------------------------------------

/**
 * @class RezFaction
 * @extends RezBasicObject
 * @description Represents a faction or group affiliation in the Rez game engine.
 * Factions can be used to organize actors, track reputation, implement conflict systems,
 * or manage group-based game mechanics. Faction objects can have attributes like
 * reputation values, member lists, or faction-specific behaviors.
 */
class RezFaction extends RezBasicObject {
  /**
   * @function constructor
   * @memberof RezFaction
   * @param {string} id - unique identifier for this faction
   * @param {object} attributes - faction attributes from Rez compilation
   * @description Creates a new faction instance
   */
  constructor(id, attributes) {
    super("faction", id, attributes);
  }
}

window.Rez.RezFaction = RezFaction;

//-----------------------------------------------------------------------------
// Game
//-----------------------------------------------------------------------------

class RezGame extends RezBasicObject {
  #containerId;
  #undoManager;
  #eventProcessor;
  #tagIndex;
  #attrIndex;
  // #wmem;
  #gameObjects;
  #view;

  constructor(id, attributes) {
    super("game", id, attributes);

    this.#undoManager = new RezUndoManager();
    this.#eventProcessor = new RezEventProcessor(this);
    this.#tagIndex = {};
    this.#attrIndex = {};
    // this.#wmem = {game: this};
    this.#gameObjects = new Map();
    this.$ = this.getGameObject;
    this.addGameObject(this);
  }

  targetType = "game";

  get undoManager() {
    return this.#undoManager;
  }

  get eventProcessor() {
    return this.#eventProcessor;
  }

  get gameObjects() {
    return this.#gameObjects;
  }

  get objectCount() {
    return this.#gameObjects.size;
  }

  get view() {
    return this.#view;
  }

  bindAs() {
    return "game";
  }

  getViewTemplate() {
    return this.$layout_template;
  }

  initLevels() {
    return [0, 1, 2, 3, 4];
  }

  saveFileName(prefix) {
    if(typeof(prefix) === "undefined") {
      prefix = this.name;
    }
    const now = new Date();
    const formatter = (num) => {
      return String(num).padStart(2, "0");
    };
    const date_parts = [
      now.getFullYear() - 2000,
      now.getMonth(),
      now.getDate(),
      now.getHours(),
      now.getMinutes(),
      now.getSeconds(),
    ];
    const dateMapped = date_parts.map(formatter);
    const dateJoined = dateMapped.join("");
    return prefix.toSnakeCase() + "_" + dateJoined + ".json";
  }

  dataArchive() {
    const archive = {};
    this.gameObjects.forEach((obj, id) => {obj.archiveInto(archive)});
    return archive;
  }

  gameArchive() {
    return {
      archive_format: this.archive_format,
      data: this.dataArchive()
    }
  }

  saveData() {
    return JSON.stringify(this.gameArchive());
  }

  get canSave() {
    return this.#view.layoutStack.length == 0;
  }

   /**
   * @function save
   * @memberof RezGame
   * @description triggers a download of the game archive
   *
   * This uses a hidden link with a 'download' attribute. The link is "clicked"
   * triggering the download of the JSON file. A timeout is used to remove the
   * link.
   */
  save() {
    this.getAll().forEach((obj) => {obj.runEvent("save_game")});

    const file = new File(
      [this.saveData()],
      this.saveFileName(this.getAttribute("name")),
      { type: "application/json" }
    );
    const link = document.createElement("a");
    link.style.display = "none";
    link.href = URL.createObjectURL(file);
    link.download = file.name;
    document.body.appendChild(link);
    link.click();
    setTimeout(() => {
      URL.revokeObjectURL(link.href);
      link.parentNode.removeChild(link);
    }, 0);
  }

  /**
   * @function load
   * @memberof RezGame
   * @param {string} source JSON format source archive
   * @description given a JSON source archive restore the game state to what was archived.
   */
  load(source) {
    const wrapper = JSON.parse(source);

    const archiveFormat = wrapper["archive_format"];
    const currentFormat = this.getAttribute("archive_format");

    if(typeof archiveFormat === "undefined") {
      throw new Error("JSON does not represent a Rez game archive!");
    } else if(archiveFormat != currentFormat) {
      throw new Error(`JSON version v${archiveFormat} different to current v${currentFormat})!`);
    } else {
      console.log(`Matching archive format: ${archiveFormat}`);
    }

    const data = wrapper["data"];
    if(typeof data === "undefined") {
      throw new Error("JSON does not contain data archive!");
    } else {
      console.log("Found data");
    }

    // Load the game's attributes and properties
    for(const [id, obj_data] of Object.entries(data)) {
      console.log(`Loading data for ${id}`);
      const obj = this.getGameObject(id);
      obj.loadData(obj_data);
      obj.runEvent("reloaded");
    }

    // Restore the game state
    this.runEvent("load_complete");

    this.current_scene.resumeFromLoad();
    this.updateViewContent();
    this.updateView();
  }

  /**
   * @function getTaggedWith
   * @memberof RezGame
   * @param {string} tag
   * @returns {array} array of indexed game-objects that have the specified tag
   * @description returns all game-objects tagged with the specified tag
   */
  getTaggedWith(tag) {
    const objects = this.#tagIndex[tag];
    if(objects) {
      return Array.from(objects);
    } else {
      return [];
    }
  }

  /**
   * For each attribute defined on this game object, add it to the game-wide
   * index for that attribute.
   * @TODO: Consider this may not work with mixed in properties as they do
   * not appear in #attributes
   *
   * @param {basic_object} elem element whose attributes are to be indexed
   */
  addToAttrIndex(elem) {
    if(!elem.isTemplateObject()) {
      Object.entries(elem.attributes).forEach(([k, v]) => {
        this.indexAttribute(elem.id, k);
      });
    }
  }

  removeFromAttrIndex(elem) {
    if(!elem.isTemplateObject()) {
      Object.entries(elem.attributes).forEach(([k, v]) => {
        this.unindexAttribute(elem.id, k);
      });
    }
  }

  /**
   * Adds the element to the per-attribute index.
   *
   * @param {string} elem_id id of element to add to the per-attr index
   * @param {string} attr_name
   */
  indexAttribute(elemId, attrName) {
    let index = this.#attrIndex[attrName] ?? new Set();
    index.add(elemId);
    this.#attrIndex[attrName] = index;
  }

  unindexAttribute(elemId, attrName) {
    let index = this.#attrIndex[attrName];
    if(index !== undefined) {
      index.delete(elemId);

      if(index.size == 0) {
        this.#attrIndex.delete(attrName);
      } else {
        this.#attrIndex[attrName] = index;
      }
    }
  }

  /**
   * Return the ids of all game elements having the specified attribute.
   *
   * @param {string} attr_name
   * @returns {Array} matching element ids
   */
  getObjectsWith(attrName) {
    const index = this.#attrIndex[attrName] ?? new Set();
    return Array.from(index);
  }

  /**
   * @function indexObjectForTag
   * @memberof RezGame
   * @param {object} obj reference to a game-object
   * @param {string} tag
   * @description applies the specified tag to the spectified game-object
   */
  indexObjectForTag(obj, tag) {
    let objects = this.#tagIndex[tag];
    if (!objects) {
      objects = new Set([obj.id]);
      this.#tagIndex[tag] = objects;
    } else {
      objects.add(obj.id)
    }
  }

  /**
   * @function unindexObjectForTag
   * @memberof RezGame
   * @param {object} obj reference to a game-object
   * @param {string} tag a tag to remove
   * @description removes the specified tag from the specified game-object
   */
  unindexObjectForTag(obj, tag) {
    let objects = this.#tagIndex[tag];
    if(objects) {
      objects.delete(obj.id);
    }
  }

  /**
   * @function addToTagIndex
   * @memberof RezGame
   * @param {object} obj game-object
   * @description indexes the specified game-object for all tags in it's tags attribute
   */
  addToTagIndex(obj) {
    const tags = obj.getAttributeValue("tags", new Set());
    tags.forEach((tag) => this.indexObjectForTag(obj, tag));
  }

  /**
   * @function removeFromTagIndex
   * @memberof RezGame
   * @param {object} obj game-object
   * @description unindexes the specified object from all tags in its tags attribute
   */
  removeFromTagIndex(obj) {
    const tags = obj.getAttributeValue("tags", new Set());
    tags.forEach((tag) => this.unindexObjectForTag(obj, tag));
  }

  /**
   * @function addGameObject
   * @memberof RezGame
   * @param {object} obj game-object
   * @description adds an object representing a game element to the game world and automatically tagging it by its attributes
  */
  addGameObject(obj) {
    if(!(obj instanceof RezBasicObject)) {
      throw new Error("Attempt to register non-game object!");
    }

    this.#gameObjects.set(obj.id, obj);
    this.addToTagIndex(obj);
    this.addToAttrIndex(obj);

    this.#undoManager?.recordNewElement(obj.id);

    return obj;
  }

  unmapObject(obj) {
    if(!(obj instanceof RezBasicObject)) {
      throw new Error("Atttempt to unmap non-game object!");
    }

    obj.runEvent("unmap", {});

    if(this.#gameObjects.delete(obj.id)) {
      this.removeFromAttrIndex(obj);
      this.removeFromTagIndex(obj);
    }

    this.#undoManager?.recordRemoveElement(obj);
  }

  /**
   * @function getGameObject
   * @memberof RezGame
   * @param {string|object} idOrRef either a string ID or a {$ref: "id"} object
   * @param {boolean} should_throw (default: true)
   * @returns {basic_object|undefined} game-object or undefined
   * @description given an element id returns the appropriate game-object reference
   *
   * Accepts both plain string IDs and {$ref: "id"} objects for backward compatibility.
   * If should_throw is true an exception will be thrown if the element id
   * is not valid. Otherwise null is returned.
   */
  getGameObject(idOrRef, shouldThrow = true) {
    const id = Rez.extractId(idOrRef);
    const obj = this.#gameObjects.get(id);
    if(typeof(obj) === "undefined") {
      if(shouldThrow) {
        throw new Error(`No such ID |${id}| found!`);
      } else {
        return undefined;
      }
    }
    return obj;
  }

  /**
   * @function getTypedGameObject
   * @memberof RezGame
   * @param {string} id id of game-object
   * @param {string} type game object type (e.g. 'actor' or 'item')
   * @param {boolean} should_throw (default: true)
   * @returns {basic_object|null} game-object or null
   */
  getTypedGameObject(id, element, shouldThrow = true) {
    const obj = this.getGameObject(id, shouldThrow);
    if(typeof(obj) !== "undefined" && obj.element !== element) {
      if(shouldThrow) {
        throw new Error(`Game object |${id}| expected to be |${element}| but was |${obj.element}|!`);
      } else {
        return undefined;
      }
    }
    return obj;
  }

  /**
   * @function elementAttributeHasChanged
   * @memberof RezGame
   * @param {object} elem reference to game-object
   * @param {string} attr_name name of the attribute whose value has changed
   * @param {*} old_value value of the attribute before the change
   * @param {*} new_value value of the attribute after the change
   * @description should be called whenever an attribute value is changed
   *
   * Currently this function notifies the undo manager and the view
   */
  elementAttributeHasChanged(elem, attrName, oldValue, newValue) {
    this.undoManager?.recordAttributeChange(elem.id, attrName, oldValue);

    if(this.#view) {
      this.#view.updateBoundControls(elem.id, attrName, newValue);
    }
  }

  /**
   * @function getRelationship
   * @memberof RezGame
   * @param {string} source_id id of game-object that holds the relationship
   * @param {string} target_id id of game-object to which the relationship refers
   * @returns {RezRelationship|null} the relationship object for this relationship
   * @description we can cheat looking up a relationship because we know how their IDs
   * are constructed.
   *
   * Note that in Rez relationships are unidirectional so that getRelationship("a", "b")
   * and getRelationship("b", "a") are different RezRelationship objects.
   */
  getRelationship(sourceId, targetId) {
    const relId = "rel_" + sourceId + "_" + targetId;
    return this.getTypedGameObject(relId, "relationship", false);
  }

  getRelationshipsOf(sourceId) {
    return this.filterObjects(
      (o) => o.element == "relationship" && o.id.startsWith(`rel_${sourceId}_`)
    );
  }

  getRelationshipsOn(targetId) {
    return this.filterObjects(
      (o) => o.element == "relationship" && o.id.endsWith(`_${targetId}`)
    );
  }

  /**
   * @function filterObjects
   * @memberof RezGame
   * @param {function} pred predicate to filter with
   * @returns {array} game-objects passing the filter
   * @description filters all game-objects returning those for which the pred filter returns true
   */
  filterObjects(pred) {
    return Array.from(this.#gameObjects.values()).filter(pred);
  }

  /**
   * @function getAll
   * @memberof RezGame
   * @param {string} target_type (optional) a specific game object type (e.g. 'actor', 'item')
   * @returns {array} game-objects with the specified type
   * @description filters all game-objects returning those with the specified type
   */
  getAll(element) {
    if(typeof element === undefined) {
      return Array.from(this.#gameObjects.values());
    } else {
      return this.filterObjects((obj) => obj.element === element);
    }
  }

  /**
   * @function startSceneWithId
   * @memberof RezGame
   * @param {string} scene_id id of scene game-object
   * @param {object} params data to pass to the new scene
   * @description finish the current scene and start the new scene with the given id
   */
  startSceneWithId(sceneId, params = {}) {
    // current_scene is a Rez attribute defined by @scene

    if(this.current_scene) {
      this.runEvent("scene_end", {});
      this.current_scene.finish();
    }

    const scene = this.getTypedGameObject(sceneId, "scene", true);

    this.current_scene = scene;

    this.updateViewContent();

    this.clearFlashMessages();
    this.runEvent("scene_start", params);
    scene.start(params);
    scene.ready();
  }

  /**
   * @function interludeSceneWithId
   * @memberof RezGame
   * @param {string} scene_id
   * @param {object} params data to pass to the new scene
   * @description interrupts the current scene, pushing it to the scene stack, and then starts the new scene with the given id
   */
  interludeSceneWithId(sceneId, params = {}) {
    // current_scene is a Rez attribute defined by @scene

    this.runEvent("scene_pause", {});
    this.pushScene();

    const scene = this.getTypedGameObject(sceneId, "scene", true);

    this.current_scene = scene;

    this.updateViewContent();

    this.clearFlashMessages();
    this.runEvent("scene_start", params);
    scene.start(params);
    scene.ready();
  }

  /**
   * @function resumePrevScene
   * @memberof RezGame
   * @param {object} params data to pass back to the previous scene
   * @description finishes the current scene, then pops the previous scene from the scene stack and resumes it
   */
  resumePrevScene(params = {}) {
    if(!this.canResume()) {
      throw new Error("Cannot resume without a scene on the stack!");
    } else {
      // Let the interlude know we're done
      this.runEvent("scene_end", {});
      this.current_scene.finish();
      this.popScene(params);
      this.runEvent("scene_resume", {});

      const layout = this.current_scene.getViewLayout();
      // Merge any new params into the existing params
      layout.params = {...layout.params, ...params};
      this.updateView();
    }
  }

  get canUndo() {
    return this.#undoManager.canUndo;
  }

  undo() {
    if(this.canUndo) {
      this.#undoManager.undo();
    }
  }

  /**
   * Informs the view of new content to be rendered. It is left up to the view
   * & its layout to determine how this affects any existing content of the view.
   *
   * @memberof RezGame
   * @param {Object} content block to be added to the view
   */
  setViewContent(content) {
    this.#view.addLayoutContent(content);
  }

  updateViewContent(params = {}) {
    const layout = this.current_scene.getViewLayout();
    layout.params = params;
    this.setViewContent(layout);
  }

  /**
   * @function updateView
   * @memberof RezGame
   * @description re-renders the view calling the 'before_render' and 'after_render'
   * game event handlers
   */
  updateView() {
    this.runEvent("before_render", {});
    this.#view.update();
    this.runEvent("after_render", {});
    this.clearFlashMessages();
  }

  restoreView(view) {
    this.#view = view;
    this.updateView();
  }

  /**
   * @function canResume
   * @memberof RezGame
   * @returns {boolean}
   * @description returns true if there is at least one scene in the scene stack
   */
  canResume() {
    return this.$scene_stack.length > 0;
  }

  /**
   * @function pushScene
   * @memberof RezGame
   * @description interrupts the current scene and puts it on the scene stack
   */
  pushScene() {
    // current_scene is an attribute defined on @game
    this.current_scene.interrupt();
    this.$scene_stack.push(this.current_scene_id);
    this.#view.pushLayout(new RezSingleLayout("scene", this));
  }

  /**
   * @function popScene
   * @memberof RezGame
   * @param {object} params data to be passed to the scene being resumed
   * @description removes the top object of the scene stack and makes it the current scene
   */
  popScene(params = {}) {
    this.#view.popLayout();
    this.current_scene_id = this.$scene_stack.pop();
    this.current_scene.resume(params);
  }

  /**
   * @function setViewLayout
   * @memberof RezGame
   * @param {*} layout ???
   * @description ???
   */
  setViewLayout(layout) {
    this.#view.setLayout(layout);
  }

  /**
   * @function start
   * @memberof RezGame
   * @param {string} container_id id of the HTML element into which game content is rendered
   * @description called automatically from the index.html this runs init on the registered game
   * objects then starts the view and starts the initial scene
   */
  start(containerId) {
    console.log("> Game.start");

    this.#containerId = containerId;

    // Init every object, will also trigger on_init for any object that defines it
    for(let init_level of this.initLevels()) {
      console.log("init/" + init_level);

      this.init(init_level);

      const game_objects = this.getAttribute("$init_order");

      game_objects.forEach(function (obj_id) {
        const obj = this.getGameObject(obj_id);
        obj.init(init_level);
      }, this);
    }

    this.getAll().forEach((obj) => {
      obj.runEvent("game_started", {})
    });

    this.runEvent("ready");

    this.buildView();
    this.startSceneWithId(this.initial_scene_id);
  }

  /**
   * Assigns the #view private attribute with a RezView that is initialized
   * with a single layout.
   */
  buildView() {
    this.#view = new RezView(
      this.#containerId,
      this.#eventProcessor,
      new RezSingleLayout("game", this)
    );
  }

  /**
   * @function getEnabledSystems
   * @memberof RezGame
   * @returns {array} all 'system' game-objects with attribute enabled=true
   */
  getEnabledSystems() {
    const filter = (o) => o.element === "system" && o.getAttributeValue("enabled");
    const order = (sys_a, sys_b) => sys_b.getAttributeValue("priority") - sys_a.getAttributeValue("priority");
    return this.filterObjects(filter).sort(order);
  }

  /**
   * @function addFlashMessage
   * @memberof RezGame
   * @param {string} message
   * @description adds the given message to the flash to be displayed on the next render
   */
  addFlashMessage(message) {
    this.$flash_messages.push(message);
  }

  /**
   * @function clearFlashMessages
   * @memberof RezGame
   * @description empties the flash messages
   */
  clearFlashMessages() {
    this.$flash_messages = [];
  }
}

window.Rez.RezGame = RezGame;

//-----------------------------------------------------------------------------
// Group
//
// Group represents a group of assets that is dynamically generated by the
// include_tag and exclude_tag attributes.
//-----------------------------------------------------------------------------

/**
 * @class RezGroup
 * @extends RezBasicObject
 * @description Represents a dynamically generated group of assets in the Rez game engine.
 * Groups filter assets based on type, include_tags, and exclude_tags attributes.
 * Provides methods for getting random assets from the filtered collection.
 */
class RezGroup extends RezBasicObject {
  /**
   * @function constructor
   * @memberof RezGroup
   * @param {string} id - unique identifier for this group
   * @param {object} attributes - group attributes including type, include_tags, exclude_tags
   * @description Creates a new asset group instance
   */
  constructor(id, attributes) {
    super("group", id, attributes);
  }

  /**
   * @function elementInitializer
   * @memberof RezGroup
   * @description Initializes the group by filtering assets during game startup
   */
  elementInitializer() {
    this.filterAssets();
  }

  /**
   * @function filterAssets
   * @memberof RezGroup
   * @description Filters all game assets based on type, include_tags, and exclude_tags
   * to build the group's asset collection. The filtered assets are shuffled and stored.
   */
  filterAssets() {
    // Start with all assets
    let assets = this.game.getAll("asset");

    // Does the asset have the right type
    const selectedType = this.getAttributeValue("type");
    assets = assets.filter((asset) => asset.type === selectedType);

    // Assets without tags can't be in a group
    assets = assets.filter((asset) => asset.hasAttribute("tags") && asset.getAttributeValue("tags").size > 0);

    // If there is an include filter, filter those without the relevant tags
    const includeTags = this.getAttributeValue("include_tags", new Set());
    if(includeTags.size > 0) {
      assets = assets.filter((asset) => {
        const tags = asset.getAttributeValue("tags");
        return tags.hasSubset(includeTags);
      });
    }

    // If there is an exclude filter, filter those with the relevant tags
    const excludeTags = this.getAttributeValue("exclude_tags", new Set());
    if(excludeTags.size > 0) {
      assets = assets.filter((asset) => {
        const tags = asset.getAttributeValue("tags");
        return tags.intersection(excludeTags).size == 0;
      });
    }

    if(assets.size == 0) {
      console.log("Attempt to create group that matches 0 assets!");
    }

    assets = assets.map((asset) => asset.id).fy_shuffle();

    this.setAttribute("assets", assets);
  }

  /**
   * @function randomAssetId
   * @memberof RezGroup
   * @returns {string} ID of a random asset from this group
   * @description Gets a random asset ID from this group, consuming it from the collection.
   * If the group is empty, it will re-filter assets first.
   * @throws {Error} if no matching assets are found
   */
  randomAssetId() {
    if(this.assets.size == 0) {
      this.filterAssets();
    }

    const assetId = this.assets.shift();
    if(typeof(assetId) === "undefined") {
      throw new Error(`Attempt to get random asset from Group |${this.id}| with no matching assets!`);
    }

    return assetId;
  }
}

// this.properties_to_archive = ["assets"];

window.Rez.RezGroup = RezGroup;

//-----------------------------------------------------------------------------
// Inventory
//-----------------------------------------------------------------------------

class RezInventory extends RezBasicObject {
  constructor(id, attributes) {
    super("inventory", id, attributes);
  }

  /**
   * @function elementInitializer
   * @memberof RezInventory
   * @description called as part of the init process this creates the inital inventory slots
   */
  elementInitializer() {
    this.addInitialContents();
  }

  addInitialContents() {
    const slots = this.getAttributeValue("slots");
    for(const slotId of slots) {
      const slot = $t(slotId, "slot", true);
      const accessor = slot.getAttributeValue("accessor");
      const slotInitialContentsAttrName = `initial_${accessor}`;
      const initialContents = this.getAttributeValue(slotInitialContentsAttrName, []);
      for(const contentId of initialContents) {
        this.addItemToSlot(slotId, contentId);
      }
    }
  }

  /**
   * @function addItemHolderForSlot
   * @memberof RezInventory
   * @param {string} slot_id
   * @description add a new slot to the inventory
   */
  addSlot(slotId) {
    const slot = $t(slotId, "slot", true);
    const attrName = `${slot.accessor}_contents`;
    if(!this.hasAttribute(attrName)) {
      this.setAttribute(attrName, []);
      this.createStaticProperty(attrName);
    }
  }

  /**
   * @function getFirstItemForSlot
   * @memberof RezInventory
   * @param {string} slot_id
   * @returns {string} id of first item in the slot
   */
  getFirstItemForSlot(slotId) {
    return this.getItemsForSlot(slotId)[0];
  }

  /**
   * @function getItemsForSlot
   * @memberof RezInventory
   * @param {string} slot_id
   * @returns {array} contents of the specified slot
   */
  getItemsForSlot(slotId) {
    const slot = this.getSlot(slotId);
    return this.getAttribute(`${slot.accessor}_contents`);
  }

  /**
   * @function slotIsOccupied
   * @memberof RezInventory
   * @param {string} slot_id
   * @returns {boolean} true if there is at least one item in the slot
   */
  slotIsOccupied(slotId) {
    return this.countItemsForSlot(slotId) > 0;
  }

  /**
   * @function getSlot
   * @memberof RezInventory
   * @param {string} slot_id
   * @returns {object} reference to the slot with the given id or throws an Error
   * if the slot is either not defined, or not part of this inventory.
   */
  getSlot(slotId) {
    if(!this.getAttribute("slots").has(slotId)) {
      throw new Error(`Inventory |${this.id}| does not have slot |${slotId}|!`);
    } else {
      return $t(slotId, "slot", true);
    }
  }

  /**
   * @function setSlot
   * @memberof RezInventory
   * @param {string} slot_id
   * @param {array} items array of item id's
   */
  setSlot(slotId, itemIds) {
    const slot = this.getSlot(slotId);
    const attrName = `${slot.accessor}_contents`;
    this.setAttribute(attrName, itemIds);
  }

  /**
   * @function appendItemToSlot
   * @member RezInventory
   * @param {string} slot_id
   * @param {string} item_id
   * @description appends the given item to the given slot
   */
  appendItemToSlot(slotId, itemId) {
    this.getItemsForSlot(slotId).push(itemId);
  }

  /**
   * @function appendItemsToSlot
   * @memberof RezInventory
   * @param {string|array} item_or_items either an item_id or array of item_id's to append to the slot
   * @description add either a single item_id or an array of item_ids to the slot
   */
  appendToSlot(slotId, itemOrItems) {
    if(Array.isArray(itemOrItems)) {
      itemOrItems.forEach((itemid) => this.appendItemToSlot(slotId, itemid));
    } else {
      this.appendItemToSlot(slotId, itemOrItems);
    }
  }

  /**
   * @function setItemForSlot
   * @memberof RezInventory
   * @param {string} item_id
   * @description replaces any existing item content for the slot with this item
   */
  setItemForSlot(slotId, itemId) {
    this.setSlot(slotId, [itemId]);
  }

  /**
   * @function setItemsForSlot
   * @memberof RezInventory
   * @param {array} items array of item ids
   * @description replaces any existing item content for the slot with these items
   */
  setItemsForSlot(slotId, items) {
    this.setSlot(slotId, items);
  }

  /**
   * @function countItemsInSlot
   * @memberof RezInventory
   * @param {string} slot_id
   * @returns {integer} number of items in the given slot
   */
  countItemsInSlot(slotId) {
    return this.getItemsForSlot(slotId).length;
  }

  /**
   * @function slotContainsItem
   * @memberof RezInventory
   * @param {string} slot_id
   * @param {string} item_id
   * @returns {boolean} true if the item_id is in the slot
   */
  slotContainsItem(slotId, itemId) {
    return this.getItemsForSlot(slotId).some((anItemId) => itemId === anItemId);
  }

  /**
   * @function containsItem
   * @memberof RezInventory
   * @param {string} item_id
   * @returns {string|null} slot_id of the slot containing the item, or null if no slot contains it
   */
  containsItem(itemId) {
    for(const slotId of this.getAttribute("slots")) {
      if(this.slotContainsItem(slotId, itemId)) {
        return slotId;
      }
    }
    return undefined;
  }

  /**
   * @function itemFitsInSlot
   * @memberof RezInventory
   * @param {string} slot_id
   * @param {string} item_id
   * @returns {boolean} true if the item will fit with any other contents of the slot
   */
  itemFitsInSlot(slotId, itemId) {
    // TODO: this code looks like shit
    const slot = $(slotId);
    if(slot.has_capacity) {
      const used_capacity = this.getItemsForSlot(slotId).reduce((amount, itemId) => {
        const item = $(itemId);
        return amount + item.size;
      });

      return used_capacity + item.size <= slot.capacity;
    } else {
      return true;
    }
  }

  /**
   * @function slotAcceptsItem
   * @memberof RezInventory
   * @param {string} slot_id
   * @param {string} item_id
   * @returns {boolean} true if the given item has a type that this slot accepts
   */
  slotAcceptsItem(slotId, itemId) {
    const slot = this.getSlot(slotid);
    const accepts = slot.getAttributeValue("accepts");
    const item = $(itemId);
    const type = item.getAttributeValue("type");

    return type === accepts;
  }

  /**
   * @function canAddItemForSlot
   * @memberof RezInventory
   * @param {string} slot_id
   * @param {string} item_id
   * @returns {boolean} true if the slot accepts the item
   */
  canAddItemForSlot(slotId, itemId) {
    const decision = new RezDecision("canItemForSlot");

    if(!this.slotAcceptsItem(slotId, itemId)) {
      decision
        .no("slot doesn't take this kind of item")
        .setData("failed_on", "accepts");
    } else if(!this.itemFitsInSlot(slotId, itemId)) {
      decision.no("does not fit").setData("failed_on", "capacity");
    } else if(this.owner != null) {
      const actorDecision = this.owner.checkItem(this.id, slotId, itemId);
      if (actorDecision.result()) {
        decision.yes();
      } else {
        decision.no(actorDecision.reason()).setData("failed_on", "actor");
      }
    } else {
      decision.yes();
    }

    return decision;
  }

  /**
   * @function canRemoveItemFromSlot
   * @memberof RezInventory
   * @param {string} slot_id
   * @param {string} item_id
   * @returns {object} RezDecision containing the result whether the item can be removed from the slot
   */
  canRemoveItemFromSlot(slotId, item_id) {
    // TODO: this code looks like shit
    const decision = new RezDecision("canRemoveItemFromSlot");
    decision.default_yes();

    const item = $(item_id);
    decision.setData("inventory_id", this.id);
    decision.setData("slot_id", slotId);
    item.canBeRemoved(item_decision);
    if(!item_decision.result) {
      return item_decision;
    }

    if(this.owner == null) {
      return decision;
    }

    this.owner.canRemoveItem(decision);
    return decision;
  }

  /**
   * @function addItemToSlot
   * @memberof RezInventory
   * @param {string} slot_id
   * @param {string} item_id
   * @description adds the given item to the given slot, notifying inventory, slot & item and applying effects
   */
  addItemToSlot(slotId, itemId) {
    const item = $(itemId);

    // Anything can be added to an inventory provided it has an `type`
    // attribute to work with the slot accepts
    if(!item.hasAttribute("type")) {
      throw new Error(`Attempt to add ${itemId} to inventory, which does not define a 'type'!`);
    }

    this.appendItemToSlot(slotId, itemId);

    this.runEvent("insert", { slot_id: slotId, item_id: itemId });

    const slot = $t(slotId, "slot");
    slot.runEvent("insert", { inventory_id: this.id, item_id: itemId });

    item.runEvent("insert", { inventory_id: this.id, slot_id: slotId});

    this.applyEffects(slotId, itemId);
  }

  /**
   * Determine whether effects should be applied to this inventory and the specified slot.
   *
   * @function shouldApplyEffects
   * @memberof RezInventory
   * @param {string} slot_id
   */
  shouldApplyEffects(slotId) {
    // apply_effects is defined in Rez @slot
    if(this.owner) {
      if(this.apply_effects) {
        const slot = $t(slotId, "slot", true);
        return slot.apply_effects;
      } else {
        return false;
      }
    } else {
      // No owner object to apply the effect to
      return false;
    }
  }

  /**
   * @function applyEffects
   * @memberof RezInventory
   * @param {string} slot_id
   * @param {string} item_id
   * @returns {boolean} whether the effect was applied
   */
  applyEffects(slotId, itemId) {
    if(!this.shouldApplyEffects(slotId)) {
      return false;
    }

    const item = $(itemId);
    if (!item.hasAttribute("effects")) {
      // This item doesn't have any effects
      return false;
    }

    for (const effectId of item.effects) {
      const effect = $t(effectId, "effect");
      effect.apply(this.owner_id, slotId, itemId);
    }

    return true;
  }

  /**
   * @function removeItemForSlot
   * @memberof RezInventory
   * @param {string} slot_id
   * @param {string} item_id
   * @description removes the specified item from the specified inventory slot
   */
  removeItemFromSlot(slotId, itemId) {
    const contents = this.getItemsForSlot(slotId);
    if (!contents.includes(itemId)) {
      throw new Error(
        "Attempt to remove item |" +
        itemId +
        "| from slot |" +
        slotId +
        "| on inventory |" +
        this.id +
        "|. No such item found!"
      );
    }

    this.setItemsForSlot(slotId, contents.filter((id) => {
      return id != itemId;
    }));

    const slot = $(slotId);
    slot.runEvent("remove", { inventory: this.id, item: itemId });

    this.runEvent("remove", { slot: slotId, item: itemId });

    this.removeEffects(slotId, itemId);
  }

  /**
   * @function removeEffects
   * @memberof RezInventory
   * @param {string} slot_id
   * @param {string} item_id
   */
  removeEffects(slotId, itemId) {
    if(!this.shouldApplyEffects(slotId)) {
      return false;
    }

    const item = $(itemId);
    if (!item.hasAttribute("effects")) {
      return false;
    }

    for (const effectId of item.effects) {
      const effect = $t(effectId, "effect");
      effect.remove(this.owner_id, slotId, itemId);
    }
  }

  /**
   * @function clearSlot
   * @memberof RezInventory
   * @param {string} slot_id
   * @description remove all items from give slot, removes any effects granted by those items
   */
  clearSlot(slotId) {
    const items = this.getItemsForSlot(slotId);
    items.forEach((itemId) => this.removeItemFromSlot(slotId, itemId));
  }
}

window.Rez.RezInventory = RezInventory;

//-----------------------------------------------------------------------------
// List
//-----------------------------------------------------------------------------

class RezList extends RezBasicObject {
  constructor(id, attributes) {
    super("list", id, attributes);
  }

  // No need to define values accessor as it's defined by default for @list

  get length() {
    return this.values.length;
  }

  // Indexed access

  at(idx) {
    return this.values.at(idx);
  }

  lookup(value) {
    return this.values.indexOf(value);
  }

  /*
   *  Returns a random element of the list with replacement.
   */
  randomElement() {
    return this.values.randomElement();
  }

  //---------------------------------------------------------------------------
  // Random without starvation (as per jkj yuio from intfiction.org)
  //---------------------------------------------------------------------------

  warmStarvationPool(poolId = "$default") {
    const warming_count = 2*this.length;
    for(let i = 0; i<warming_count; i++ ) {
      this.randomWithoutStarvation(poolId);
    }
  }

  randomWithoutStarvation(poolId = "$default") {
    let stats = this.getAttributeValue(`$pool_${poolId}`, Array.nOf(this.length, 0));
    const len = stats.length;
    const max = Math.floor(len + (len+2)/3);

    // Increment all counters first
    stats = stats.map((element) => element+1);

    // Find elements that are now starving
    let starvingIndices = stats
      .map((el, idx) => el >= max ? idx : -1)
      .filter(idx => idx !== -1);

    // Choose: starving element if any exist, otherwise random
    let choice = starvingIndices.length > 0
      ? starvingIndices.randomElement()
      : stats.randomIndex();

    // Reset chosen element
    stats[choice] = 0;

    this.setAttribute(`$pool_${poolId}`, stats);
    return this.values[choice];
  }

  //---------------------------------------------------------------------------
  // Cycle
  //---------------------------------------------------------------------------

  /*
   * Treat the list as a repeating cycle. Each cycle identified by an id
   * is separate.
   */
  nextForCycle(cycleId) {
    const cycleIdx = this.getAttributeValue(`cycle_${cycleId}`, 0);
    const values = this.getAttribute("values");
    const value = values.at(cycle_idx);
    cycleIdx = (cycleIdx + 1) % values.length;
    this.setAttribute(`cycle_${cycleId}`, cycleIdx);
    return value;
  }

  //---------------------------------------------------------------------------
  // Bag
  //---------------------------------------------------------------------------

  randomFromBag(bagId = "$default") {
    const item = this.randomRemaining(bagId);
    this.takeFrom(bagId, item);
    return item;
  }

  // Low-level interface, you should not need to call these directly

  /*
   * Returns a random element from among those left in the bag. If the bag
   * is empty, returns undefined.
   */
  randomRemaining(bagId) {
    let bag = this.getBag(bagId);
    if(bag.length === 0) {
      return undefined;
    } else {
      return bag.randomElement();
    }
  }

  /*
   * Removes the specified value from those in the bag
   */
  takeFrom(bagId, value) {
    let bag = this.getBag(bagId);
    bag = bag.filter((elem) => elem != value);
    this.setBag(bagId, bag);
  }

  getBag(bagId) {
    const attrName = `bag_${bagId}`;
    if(!this.hasAttribute(attrName)) {
      this.createBag(bagId);
    }
    return this.getAttributeValue(attrName);
  }

  setBag(bagId, bag) {
    const attrName = `bag_${bagId}`;
    this.setAttribute(attrName, bag);
  }

  createBag(bagId) {
    const values = this.getAttribute("values");
    const bag = Array.from(values);
    this.setBag(bagId, bag);
    return bag;
  }

  //---------------------------------------------------------------------------
  // Walk
  //---------------------------------------------------------------------------

  /*
   * Returns a random element of the list without replacement, i.e. no item
   * will be returned twice in any given walk. At the end of a walk (i.e. all items
   * have been returned), a new walk is automatically begun.
   */
  randomWalk(walkId) {
    let walk = this.getWalk(walkId);
    if (walk.length == 0) {
      walk = this.resetWalk(walkId);
    } else {
      const idx = walk.shift();
      const values = this.getAttribute("values");
      return values.at(idx);
    }
  }

  getWalk(walkId) {
    let walk = this.getAttributeValue(`walk_${walkId}`);
    if(typeof(walk) === "undefined") {
      return this.resetWalk();
    } else {
      return walk;
    }
  }

  resetWalk(walkId) {
    const values = this.getAttribute("values");
    const walk = Array.from(values.keys()).fy_shuffle();
    this.setAttribute(`walk_${walkId}`, walk);
    return walk;
  }
}

window.Rez.RezList = RezList;

//-----------------------------------------------------------------------------
// Object
//
// The RezObject is a way for authors to define their own types of object
// that don't belong to one of the provided functionalities (e.g. actors,
// items, and the like). An author can define a RezObject and put whatever
// data they like into it and make use of it from their own scripted functions
// or behaviours.
//-----------------------------------------------------------------------------

class RezObject extends RezBasicObject {
  constructor(id, attributes) {
    super("object", id, attributes)
  }
}

window.Rez.RezObject = RezObject;

//-----------------------------------------------------------------------------
// Plot
//-----------------------------------------------------------------------------

class RezPlot extends RezBasicObject {
  constructor(id, attributes) {
    super("plot", id, attributes);
  }

  get isComplete() {
    return this.stage == this.stages;
  }

  advance() {
    if(this.stage < this.stages) {
      this.stage += 1;
      this.runEvent("advance", {});
    }
  }
}

window.Rez.RezPlot = RezPlot;

//-----------------------------------------------------------------------------
// Relationship
//-----------------------------------------------------------------------------

/**
 * @class RezRelationship
 * @extends RezBasicObject
 * @description Represents a relationship between two game objects in the Rez game engine.
 * Relationships are directional (source -> target) and can have attributes like strength,
 * type, or other relationship-specific data. Each relationship automatically gets
 * source_id and target_id attributes that reference the related objects.
 */
class RezRelationship extends RezBasicObject {
  /**
   * @function constructor
   * @memberof RezRelationship
   * @param {string} id - unique identifier for this relationship (typically "rel_sourceId_targetId")
   * @param {object} attributes - relationship attributes including source_id and target_id
   * @description Creates a new relationship instance between two game objects
   */
  constructor(id, attributes) {
    super("relationship", id, attributes);
  }

  // The @relationship element will define source_id and target_id
  // attributes, leading to source & target being defined automatically

  /**
   * @function inverse
   * @memberof RezRelationship
   * @returns {RezRelationship|null} the inverse relationship (target -> source) or null if it doesn't exist
   * @description Gets the inverse relationship where the target and source are swapped.
   * Since relationships are directional, the inverse represents the relationship in the opposite direction.
   */
  get inverse() {
    return this.game.getRelationship(this.target_id, this.source_id);
  }
}

window.Rez.RezRelationship = RezRelationship;

//-----------------------------------------------------------------------------
// Scene
//-----------------------------------------------------------------------------

/**
 * @class RezScene
 * @extends RezBasicObject
 * @description Represents a scene in the Rez game engine. Scenes manage the flow of cards and content,
 * handling transitions between different parts of the game narrative. Each scene has a layout mode
 * (single or stack) and manages the current card being displayed.
 */
class RezScene extends RezBasicObject {
  /**
   * @function constructor
   * @memberof RezScene
   * @param {string} id - unique identifier for this scene
   * @param {object} attributes - scene attributes from Rez compilation
   * @description Creates a new scene instance and initializes it to a reset state
   */
  constructor(id, attributes) {
    super("scene", id, attributes);
    this.reset();
  }

  targetType = "scene";

  /**
   * @function isStackLayout
   * @memberof RezScene
   * @returns {boolean} true if this scene uses stack layout mode
   * @description Determines if this scene stacks cards on top of each other (stack mode)
   * or replaces the current card with each new one (single mode)
   */
  get isStackLayout() {
    return this.layout_mode === "stack";
  }

  /**
   * @function current_block
   * @memberof RezScene
   * @returns {RezLayout} the current view layout for this scene
   * @description Returns the view layout that manages how content is displayed in this scene
   */
  get current_block() {
    return this.getViewLayout()
  }

  /**
   * @function bindAs
   * @memberof RezScene
   * @returns {string} "scene"
   * @description Returns the binding identifier for template rendering
   */
  bindAs() {
    return "scene";
  }

  /**
   * @function getViewTemplate
   * @memberof RezScene
   * @param {boolean} flipped - ignored for scenes (only cards can be flipped)
   * @returns {*} the template used to render this scene's layout
   * @description Returns the layout template for rendering this scene. The flipped parameter is ignored since scenes cannot be flipped.
   */
  getViewTemplate(flipped) {
    // Scenes can't be flipped, only cards
    return this.$layout_template;
  }

  /**
   * @function getViewLayout
   * @memberof RezScene
   * @returns {RezLayout} the view layout instance for this scene
   * @description Gets or creates the view layout for this scene. The layout is cached and reused.
   */
  getViewLayout() {
    this.$viewLayout = this.$viewLayout ?? this.createViewLayout();
    return this.$viewLayout;
  }

  /**
   * @function createViewLayout
   * @memberof RezScene
   * @returns {RezStackLayout|RezSingleLayout} the appropriate layout instance
   * @description Creates a new view layout based on the scene's layout mode.
   * Returns RezStackLayout for stack mode or RezSingleLayout for single mode.
   */
  createViewLayout() {
    if(this.isStackLayout) {
      return new RezStackLayout("scene", this);
    } else {
      return new RezSingleLayout("scene", this);
    }
  }

  /**
   * @function playCardWithId
   * @memberof RezScene
   * @param {string} cardId - ID of the card to play
   * @param {object} params - parameters to pass to the card
   * @description Plays a card by looking it up by ID and calling playCard with the card instance
   */
  playCardWithId(cardId, params = {}) {
    this.playCard($t(cardId, "card", true), params);
  }

  /**
   * @function playCard
   * @memberof RezScene
   * @param {RezCard} newCard - the card instance to play
   * @param {object} params - parameters to pass to the card
   * @description Transitions to a new card, finishing the current card if any, starting the new one,
   * updating the view, and triggering the card's ready event.
   */
  playCard(newCard, params = {}) {
    this.finishCurrentCard();

    this.startNewCard(newCard, params);
    this.game.updateView();
    this.current_card.runEvent("ready", {});
  }

  /**
   * @function finishCurrentCard
   * @memberof RezScene
   * @description Finishes the currently active card by running its finish event,
   * triggering the scene's finish_card event, and in stack layout mode, flipping the card.
   */
  finishCurrentCard() {
    if(this.current_card) {
      this.current_card.runEvent("finish", {});
      this.runEvent("finish_card", {});
      if(this.isStackLayout) {
        this.current_card.current_block.flipped = true;
      }
      this.last_card_id = this.current_card_id;
      this.current_card_id = "";
    }
  }

  /**
   * @function startNewCard
   * @memberof RezScene
   * @param {RezCard} card - the card to start
   * @param {object} params - parameters to pass to the card
   * @description Sets up a new card as the current card, adds it to the view layout,
   * and triggers the appropriate start events.
   */
  startNewCard(card, params = {}) {
    card.scene = this;
    this.current_card = card;

    this.addContentToViewLayout(params);

    this.runEvent("start_card", {});
    card.runEvent("start", {});
  }

  /**
   * @function resumeFromLoad
   * @memberof RezScene
   * @description Resumes the scene after loading from a saved game state.
   * Ensures the current card is properly restored to the view layout.
   * @throws {Error} if no current card is available to resume
   */
  resumeFromLoad() {
    if(!(this.current_card instanceof RezCard)) {
      throw new Error("Attempting to resume scene after reload but there is no current card!");
    }

    this.addContentToViewLayout({});
  }

  /**
   * @function addContentToViewLayout
   * @memberof RezScene
   * @param {object} params - parameters to pass to the content block
   * @description Creates a new content block for the current card and adds it to the scene's view layout
   */
  addContentToViewLayout(params = {}) {
    const block = new RezBlock("card", this.current_card, params);
    this.current_card.current_block = block;
    this.getViewLayout().addContent(block);
  }

  /**
   * @function reset
   * @memberof RezScene
   * @description Resets the scene to its initial state, clearing the current card,
   * view layout, and running status
   */
  reset() {
    this.current_card_id = "";
    this.$viewLayout = null;
    this.$running = false;
  }

  /**
   * @function interrupt
   * @memberof RezScene
   * @description Interrupts the current scene execution, typically when switching to an interlude scene.
   * Triggers the scene's interrupt event.
   */
  interrupt() {
    console.log(`Interrupting scene |${this.id}|`);
    this.runEvent("interrupt", {});
  }

  /**
   * @function resume
   * @memberof RezScene
   * @param {object} params - parameters passed from the interlude scene
   * @description Resumes the scene after an interlude, triggering the scene's resume event
   */
  resume(params = {}) {
    console.log(`Resuming scene |${this.id}|`);
    this.runEvent("resume", params);
  }

  /**
   * @function start
   * @memberof RezScene
   * @param {object} params - parameters to pass to the scene and initial card
   * @description Starts the scene by initializing it, triggering the start event,
   * setting the running state, and playing the initial card
   */
  start(params = {}) {
    this.init();
    this.runEvent("start", params);
    this.$running = true;
    this.playCard(this.initial_card, params);
  }

  /**
   * @function ready
   * @memberof RezScene
   * @description Triggers the scene's ready event, indicating the scene is fully initialized and ready for interaction
   */
  ready() {
    this.runEvent("ready", {});
  }

  /**
   * @function finish
   * @memberof RezScene
   * @description Finishes the scene by completing the current card, triggering the finish event,
   * setting running state to false, and resetting the scene
   */
  finish() {
    this.finishCurrentCard();
    this.runEvent("finish", {});
    this.$running = false;
    this.reset();
  }
}

window.Rez.RezScene = RezScene;

//-----------------------------------------------------------------------------
// Slot
//-----------------------------------------------------------------------------

/**
 * @class RezSlot
 * @extends RezBasicObject
 * @description Represents an inventory slot in the Rez game engine. Slots define
 * compartments within inventories where items can be stored. Each slot has properties
 * like capacity, item type restrictions, and accessor names for template binding.
 */
class RezSlot extends RezBasicObject {
  /**
   * @function constructor
   * @memberof RezSlot
   * @param {string} id - unique identifier for this slot
   * @param {object} attributes - slot attributes from Rez compilation including capacity and restrictions
   * @description Creates a new inventory slot instance
   */
  constructor(id, attributes) {
    super("slot", id, attributes);
  }
}

window.Rez.RezSlot = RezSlot;

//-----------------------------------------------------------------------------
// System
//-----------------------------------------------------------------------------

/**
 * @class RezSystem
 * @extends RezBasicObject
 * @description Represents a game system in the Rez game engine. Systems are used to implement
 * cross-cutting game mechanics that operate on events and game state. They can define
 * before_event and after_event handlers that are called during event processing, allowing
 * them to modify events and results. Systems have priority and enabled/disabled states.
 */
class RezSystem extends RezBasicObject {
  /**
   * @function constructor
   * @memberof RezSystem
   * @param {string} id - unique identifier for this system
   * @param {object} attributes - system attributes from Rez compilation including priority and handlers
   * @description Creates a new game system instance
   */
  constructor(id, attributes) {
    super("system", id, attributes);
  }
}

window.Rez.RezSystem = RezSystem;

/**
 * @class RezTimer
 * @extends RezBasicObject
 * @description Represents a timer in the Rez game engine. Timers can be configured to run once or repeatedly,
 * with optional count-down functionality. When triggered, they dispatch timer events through the game's event processor.
 */
class RezTimer extends RezBasicObject {
  #timer;

  /**
   * @function constructor
   * @memberof RezTimer
   * @param {string} id - unique identifier for this timer
   * @param {object} attributes - timer attributes from Rez compilation
   * @description Creates a new timer instance with the specified configuration
   */
  constructor(id, attributes) {
    super("timer", id, attributes);
  }

  /**
   * @function running
   * @memberof RezTimer
   * @returns {boolean} true if the timer is currently active
   * @description Indicates whether the timer is currently running and will trigger events
   */
  get running() {
    return this.#timer != null;
  }

  /**
   * @function start
   * @memberof RezTimer
   * @description Starts the timer using either setInterval (for repeating timers) or setTimeout (for one-shot timers).
   * The timer will trigger the notify method when it fires.
   */
  start() {
    const timerHandler = this.notify.bind(this);
    if(this.repeats) {
      this.#timer = setInterval(timerHandler, this.interval);
    } else {
      this.#timer = setTimeout(timerHandler, this.interval);
    }
  }

  /**
   * @function dec_counter
   * @memberof RezTimer
   * @description Decrements the timer's count attribute if present. When count reaches zero,
   * the timer automatically stops itself.
   */
  dec_counter() {
    if(this.hasAttribute("count")) {
      let count = this.getAttribute("count") - 1;
      if(count === 0) {
        this.stop();
      }
      this.setAttribute("count", count);
    }
  }

  /**
   * @function notify
   * @memberof RezTimer
   * @description Called when the timer fires. Decrements the count (if present) and dispatches a timer event
   * through the game's event processor.
   */
  notify() {
    this.dec_counter();
    const eventProcessor = this.game.eventProcessor;
    eventProcessor.dispatchResponse(eventProcessor.raiseTimerEvent(this));
  }

  /**
   * @function stop
   * @memberof RezTimer
   * @description Stops the timer by clearing the timeout/interval and resetting the internal timer reference
   */
  stop() {
    clearTimeout(this.#timer);
    this.#timer = null;
  }
}

window.Rez.RezTimer = RezTimer;

// Obvious deficiencies:
// We don't consider what happens if an element gets removed, we should bring
// it back during undo.
class RezUndoManager {
  #changeList;
  #maxSize;
  #performingUndo;  // Flag to track if we're currently in an undo operation

  constructor(maxSize = 16) {
    this.#maxSize = maxSize;
    this.reset();
  }

  reset() {
    this.#changeList = [];
    this.#performingUndo = false;
  }

  get canUndo() {
    return !this.#performingUndo && this.#changeList.length > 0;
  }

  get historySize() {
    return this.#changeList.length;
  }

  get curChange() {
    return this.#changeList.length > 0 ? this.#changeList.at(-1) : null;
  }

  get performingUndo() {
    return this.#performingUndo;
  }

  startChange() {
    // Don't start a new change record if we're in the middle of an undo operation
    if(!this.#performingUndo) {
      if(this.#changeList.length >= this.#maxSize) {
        this.#changeList.shift(); // Remove the first (oldest) element
      }
      this.#changeList.push([]);
    }
  }

  recordNewElement(elemId) {
    if(!this.#performingUndo) {
      this.curChange?.unshift({
        changeType: "newElement",
        elemId: elemId
      });
    }
  }

  /**
   * Discard the most recent change. This is used during an undo when the event
   * the triggers the undo has started a new change.
   */
  #discardChange() {
    this.#changeList.pop();
  }

  recordRemoveElement(elem) {
    if(!this.#performingUndo) {
      this.curChange?.unshift({
        changeType: "removeElement",
        elem: elem
      });
    }
  }

  recordAttributeChange(elemId, attrName, oldValue) {
    if(!this.#performingUndo) {
      this.curChange?.unshift({
        changeType: "setAttribute",
        elemId: elemId,
        attrName: attrName,
        oldValue: oldValue
      });
    }
  }

  recordViewChange(view) {
    if(!this.#performingUndo) {
      this.curChange?.unshift({
        changeType: "view",
        view: view
      });
    }
  }

  undo(manualUndo = false) {
    if(this.canUndo) {

      // Set flag to prevent recording changes during undo
      this.#performingUndo = true;

      try {
        console.log("RezUndoManager: Starting undo operation");

        if(!manualUndo) {
          this.#discardChange();
        }
        const changes = this.#changeList.pop();

        console.log(`RezUndoManager: Undoing ${changes.length} changes`);
        console.dir(changes);

        // Apply all regular changes
        changes.forEach((change) => {
          if (change.changeType === "newElement") {
            this.#undoNewElement(change);
          } else if (change.changeType === "setAttribute") {
            this.#undoSetAttribute(change);
          } else if (change.changeType === "removeElement") {
            this.#undoRemoveElement(change);
          } else if (change.changeType === "view") {
            this.#undoViewChange(change);
          } else {
            throw new Error(`Unknown change type: ${change.changeType}`);
          }
        });

      } finally {
        // Clear the flag when we're done
        this.#performingUndo = false;
      }
    }
  }

  #undoNewElement({elemId}) {
    $(elemId, true).unmap();
  }

  #undoRemoveElement({elem}) {
    $game.addGameObject(elem);
  }

  #undoSetAttribute({elemId, attrName, oldValue}) {
    $(elemId, true).setAttribute(attrName, oldValue);
  }

  #undoViewChange({view}) {
    $game.restoreView(view)
  }
}

window.Rez.RezUndoManager = RezUndoManager;
//-----------------------------------------------------------------------------
// Templates use this for conditionals
//-----------------------------------------------------------------------------

function evaluateExpression(expression, bindings, rval = true) {
  const proxy = new Proxy(
    {},
    {
      get: (target, property) => {
        if (bindings.hasOwnProperty(property)) {
          return bindings[property];
        }
        return undefined;
      },
    }
  );

  const argNames = Object.keys(bindings);
  const argValues = argNames.map((name) => proxy[name]);

  // Create a new function with bindings as arguments and the expression as the body
  let func;
  if(rval) {
    func = new Function(...argNames, `return ${expression};`);
  } else {
    func = new Function(...argNames, `${expression}`);
  }

  // Invoke the function with the values from the bindings
  return func(...argValues);
}

//-----------------------------------------------------------------------------
// View
//-----------------------------------------------------------------------------

class RezBlock {
  #parentBlock;
  #blockType;
  #source;
  #flipped;
  #params;

  constructor(blockType, source, params = {}) {
    this.#parentBlock = null;
    this.#blockType = blockType;
    this.#source = source;
    this.#flipped = false;
    this.#params = params;
  }

  get parentBlock() {
    return this.#parentBlock;
  }

  set parentBlock(block) {
    this.#parentBlock = block;
  }

  get blockType() {
    return this.#blockType;
  }

  set blockType(type) {
    this.#blockType = type;
  }

  get source() {
    return this.#source;
  }

  set source(source) {
    this.#source = source;
  }

  get flipped() {
    return this.#flipped;
  }

  set flipped(is_flipped) {
    this.#flipped = is_flipped;
  }

  get params() {
    return this.#params;
  }

  set params(params) {
    this.#params = params;
  }

  instantiateIdBinding(id) {
    return $(id);
  }

  instantiatPropertyBinding(ref) {
    const target = $(ref.elem_id);
    return target[ref.attr_name];
  }

  instantiateFunctionBinding(bindings, f) {
    if (this.parentBlock) {
      return f(this, this.parentBlock.source, bindings);
    } else {
      return f(this, null, bindings);
    }
  }

  instantiateBindingPath(p) {
    return p(this.source);
  }

  instantiatePathBinding(path_fn, bindings) {
    return path_fn(bindings);
  }

  resolveBindingValue(bindings, bindingObject) {
    const { source, literal, deref } = bindingObject;

    // Handle literal values first
    if (literal !== undefined) {
      return literal;
    }

    // Validate source
    if (source === undefined || source === null) {
      throw new Error('Binding source is undefined or null');
    }

    // Resolve binding based on source type
    return this.extractBindingValue(bindings, source, deref);
  }

  extractBindingValue(bindings, source, deref = false) {
    let value;
    if (typeof source === "string") {
      value = this.instantiateIdBinding(source);
    } else if(Rez.isElementRef(source)) {
      value = this.instantiateIdBinding(source.$ref);
    } else if (typeof source === "function") {
      value = this.instantiateFunctionBinding(bindings, source);
    } else if (source && typeof source.binding === "function") {
      value = this.instantiatePathBinding(source.binding, bindings);

      // Apply dereferencing only for path bindings when deref is true
      if (deref) {
        value = this.dereferenceBoundValue(value);
      }
    } else {
      // Detailed error for unrecognized source type
      throw new Error(`Invalid binding source type: ${typeof source}.
        Expected string, function, or object with binding function.`);
    }

    return value;
  }

  dereferenceBoundValue(value) {
    if (Array.isArray(value)) {
      return value.map(ref => $(ref));  // $(ref) now handles both string and {$ref: "id"} formats
    }

    return $(value);  // $(value) now handles both string and {$ref: "id"} formats
  }

  getBindings(initialBindings) {
    const sourceBindings = this.source.getAttributeValue("bindings", []);

    if(this.source.getAttributeValue("$debug_bindings", false)) {
      console.log(`Binding source: ${this.source.id}`);
      console.log("Inital Bindings");
      console.dir(initialBindings);

      console.log("Bindings");
      console.dir(sourceBindings);
    }

    return sourceBindings.reduce((bindings, bindingObject) => {
      const prefix = bindingObject["prefix"];
      const value = this.resolveBindingValue(bindings, bindingObject);

      bindings[prefix] = value;
      return bindings;
    }, initialBindings);
  }

  bindValues() {
    const initialBindings = {
      block: this,
      params: this.params,
      source: this.source,
      [this.source.bindAs()]: this.source
    };

    return this.getBindings(initialBindings);
  }

  // blocks are a list of id's of other card elements that we
  // want to sub-render and make available to the template of this
  // card. The result is a map of key pairs {block_id, block_render}
  getBlocks() {
    const blocks = this.source.getAttributeValue("blocks", []);
    return blocks.reduce((blockMappings, blockId) => {
      const blockSource = $(blockId);
      blockSource.$parent = this.source;
      const block = new RezBlock("block", blockSource);
      block.parentBlock = this;
      blockMappings[blockId] = block;
      return blockMappings;
    }, {});
  }

  bindBlocks() {
    return this.getBlocks().objMap((block) => block.html());
  }

  getViewTemplate() {
    return this.source.getViewTemplate(this.flipped);
  }

  parentBindings() {
    if (this.parentBlock) {
      return this.parentBlock.bindValues();
    } else {
      return {};
    }
  }

  bindings() {
    const bindings = {
      ...this.parentBindings(),
      ...this.bindValues(),
      ...this.bindBlocks(),
    };

    return bindings;
  }

  renderBlock() {
    const template = this.getViewTemplate();
    const bindings = this.bindings();
    return template(bindings);
  }

  css_classes() {
    if (this.blockType == "block") {
      return "rez-block";
    } else if (this.blockType == "card") {
      if (this.flipped) {
        return "rez-card rez-flipped-card";
      } else {
        return "rez-card rez-active-card";
      }
    } else {
      throw new Error("This shouldn't happen, right?");
    }
  }

  html() {
    const blockContent = this.renderBlock();

    if(this.source.$suppress_wrapper) {
      return blockContent;
    } else {
      return `<div class="${this.css_classes()}">${blockContent}</div>`;
    }
  }

  _copyInto(target) {
    target.parentBlock = this.parentBlock;
    target.blockType = this.blockType;
    target.source = this.source;
    target.flipped = this.flipped;
    target.params = this.params;
    return target;
  }

  copy() {
    const copiedBlock = new this.constructor();
    return this._copyInto(copiedBlock);
  }
};

window.Rez.RezBlock = RezBlock;

//-----------------------------------------------------------------------------
// Layout
//-----------------------------------------------------------------------------

class RezLayout extends RezBlock {
  constructor(blockType, source) {
    super(blockType, source);
  }

  addContent(block) {
    throw new Error("Must implement addContent(block)");
  }

  renderContents() {
    throw new Error("Must implement renderContents()");
  }

  bindAs() {
    throw new Error("Must implement bindAs()");
  }

  html() {
    const renderedContent = this.renderContents();
    const templateFn = this.getViewTemplate();
    const boundValues = this.bindValues();
    const boundBlocks = this.bindBlocks();
    return templateFn({
      content: renderedContent,
      // ...this.parentBindings(),
      ...boundValues,
      ...boundBlocks,
    });
  }
}

//-----------------------------------------------------------------------------
// Single Layout
//
// This Layout holds a single block as it's content
//-----------------------------------------------------------------------------

class RezSingleLayout extends RezLayout {
  #content;

  constructor(sourceName, source) {
    super(sourceName, source);
    this.#content = null;
  }

  bindAs() {
    return this.blockType;
  }

  addContent(block) {
    block.parentBlock = this;
    this.#content = block;
  }

  renderContents() {
    return this.#content.html();
  }

  _copyInto(target) {
    target.#content = this.#content;
    return target;
  }

  copy() {
    const copiedLayout = new this.constructor();
    super._copyInto(copiedLayout)
    copiedLayout.#content = this.#content.copy();
    return copiedLayout;
  }
}

window.Rez.RezSingleLayout = RezSingleLayout;

//-----------------------------------------------------------------------------
// Stack Layout
//
// This layout holds a list of blocks that are composed to form its content
//-----------------------------------------------------------------------------

class RezStackLayout extends RezLayout {
  #contents;

  constructor(sourceName, source) {
    super(sourceName, source);
    this.#contents = [];
  }

  bindAs() {
    return this.blockType;
  }

  get reversed() {
    return this.source.layout_reverse;
  }

  addContent(block) {
    block.parentBlock = this;

    if (this.reversed) {
      this.#contents.unshift(block);
    } else {
      this.#contents.push(block);
    }
  }

  renderContents() {
    let separator = "";
    if (this.source.layout_separator) {
      separator = this.source.layout_separator;
    }

    return this.#contents.map((block) => block.html()).join(separator);
  }

  copy() {
    const copiedLayout = new this.constructor();
    super._copyInto(copiedLayout);
    copiedLayout.#contents = this.#contents.copy();
    return copiedLayout;
  }
};

window.Rez.RezStackLayout = RezStackLayout;

//-----------------------------------------------------------------------------
// Transformers
//
// A transformer uses a CSS selector to find certain elements in the rendered
// content and do something with them.
//
// The getSelector() method returns a CSS selector that defines which elements
// are to be transformed.
//
// The transformeElement() method should overridden and will get passed each
// matching element and should transform it.
//-----------------------------------------------------------------------------

class RezTransformer {
  #selector;
  #eventName;
  #receiver;

  constructor(selector, eventName = null, receiver = null) {
    if (typeof selector === "undefined") {
      throw "Undefined selector!";
    }
    if (typeof eventName === "undefined") {
      throw "Undefined eventName!";
    }
    if (typeof receiver === "undefined") {
      throw "Undefined receiver!";
    }

    this.#selector = selector;
    this.#eventName = eventName;
    this.#receiver = receiver;
  }

  get selector() {
    return this.#selector;
  }

  get eventName() {
    return this.#eventName;
  }

  get receiver() {
    return this.#receiver;
  }

  get elements() {
    return document.querySelectorAll(this.#selector);
  }

  transformElements(view) {
    this.elements.forEach((elem) => {
      this.transformElement(elem, view);
    });
  }

  transformElement(elem, view) {
    throw "Transformers must implement transformElement(elem, view)!";
  }
}

//-----------------------------------------------------------------------------
// Event Transformers
//
// An Event Transformer is used to add an event handler listener to the
// matching elements.
//
// It expects a receiver property that defines the object which handles
// events raised and an event property that specifies the name of the event
// to be registered.
//
// The receiver is expected to define two methods:
//    handleBrowserEvent
//    dispatchResponse
// the collective define the response to the event.
//-----------------------------------------------------------------------------

class RezEventTransformer extends RezTransformer {
  constructor(selector, event, receiver) {
    super(selector, event, receiver);
  }

  addEventListener(elem) {
    const transformer = this;
    elem.addEventListener(this.eventName, function (evt) {
      evt.preventDefault();

      // A handler should return an object with keys representing the side-
      // effects of an event.
      // {scene: "scene_id"}
      // Load a new scene
      // {card: "card_id"}
      // Play a card into the current scene
      // {flash: "flash message"}
      // Update the current flash
      // {render: true}
      // Trigger a re-render of the view
      // {error: "Error Message"}
      // Log an error message
      const receiver = transformer.receiver;
      receiver.dispatchResponse(receiver.handleBrowserEvent(evt));
    });
  }

  transformElement(elem, view) {
    this.addEventListener(elem);
  }
}

//-----------------------------------------------------------------------------
// Block Transformer
//
// A Block Transformer operates on a <div class="card" data-card="...">
// blocks.
//-----------------------------------------------------------------------------
class RezBlockTransformer extends RezTransformer {
  constructor() {
    super("div.rez-card div[data-card]");
  }

  transformElement(elem, view) {
    const elem_id = elem.dataset.card;
    elem.rez_card = $(elem_id);
  }

}

window.Rez.RezBlockTransformer = RezBlockTransformer;

//-----------------------------------------------------------------------------
// Link Transformers
//
// Link Transformers operate on <a data-event="..."> tags within a
// <div class="card">.
//-----------------------------------------------------------------------------

class RezEventLinkTransformer extends RezEventTransformer {
  constructor(receiver) {
    super("div.rez-front-face a[data-event], div.rez-active a[data-event]", "click", receiver);
  }
}

window.Rez.RezEventLinkTransformer = RezEventLinkTransformer;

//-----------------------------------------------------------------------------
// Button Transformer
//-----------------------------------------------------------------------------

class RezButtonTransformer extends RezEventTransformer {
  constructor(receiver) {
    super("div.rez-front-face button[data-event]:not(.inactive)", "click", receiver);
  }
}

window.Rez.RezButtonTransformer = RezButtonTransformer;

//-----------------------------------------------------------------------------
// FormTransformer
//-----------------------------------------------------------------------------

class RezFormTransformer extends RezEventTransformer {
  constructor(receiver) {
    super("div.rez-front-face form[rez-live]", "submit", receiver);
  }
}

window.Rez.RezFormTransformer = RezFormTransformer;

//-----------------------------------------------------------------------------
// InputTransformer
//-----------------------------------------------------------------------------

class RezInputTransformer extends RezEventTransformer {
  constructor(receiver) {
    super("div.rez-front-face input[rez-live]", "input", receiver);
  }
}

window.Rez.RezInputTransformer = RezInputTransformer;

//-----------------------------------------------------------------------------
// EnterKeyTransformer
//-----------------------------------------------------------------------------

class RezEnterKeyTransformer extends RezEventTransformer {
  constructor(receiver) {
    super("div.rez-front-face form[rez-live] input[type='text'], div.rez-front-face form[rez-live] input[type='email'], div.rez-front-face form[rez-live] input[type='password'], div.rez-front-face form[rez-live] input[type='search'], div.rez-front-face form[rez-live] input[type='url'], div.rez-front-face form[rez-live] input[type='tel'], div.rez-front-face form[rez-live] input[type='number'], div.rez-front-face form[rez-live] input:not([type])", "keydown", receiver);
  }

  addEventListener(elem) {
    const transformer = this;
    elem.addEventListener(this.eventName, function (evt) {
      if(evt.key === "Enter") {
        evt.preventDefault();

        // Find the parent form
        const form = evt.target.closest("form[rez-live]");

        if(form) {
          const formName = form.getAttribute("name");

          if(!formName) {
            console.error("RezEnterKeyTransformer: Form has no name attribute!");
            return;
          }

          // Create a synthetic submit event with correct target and type
          const submitEvent = new Event("submit", { bubbles: true, cancelable: true });
          Object.defineProperty(submitEvent, 'target', { value: form, enumerable: true });
          Object.defineProperty(submitEvent, 'type', { value: 'submit', enumerable: true });

          // Use the receiver's handleBrowserEvent method (which routes to handleBrowserSubmitEvent)
          transformer.receiver.dispatchResponse(
            transformer.receiver.handleBrowserEvent(submitEvent)
          );
        } else {
          console.error("RezEnterKeyTransformer: No rez-live form found!");
        }
      }
    });
  }
}

window.Rez.RezEnterKeyTransformer = RezEnterKeyTransformer;

//-----------------------------------------------------------------------------
// BindingTransformer
//-----------------------------------------------------------------------------

class RezBindingTransformer extends RezTransformer {
  constructor(receiver) {
    super("div.rez-front-face input[rez-bind], select[rez-bind], textarea[rez-bind]");
  }

  decodeBinding(binding_expr) {
    const [binding_id, binding_attr] = binding_expr.split(".");
    if (
      typeof binding_id === "undefined" ||
      typeof binding_attr === "undefined"
    ) {
      throw `Unable to parse binding: ${binding_expr}`;
    }

    return [binding_id, binding_attr];
  }

  getBoundElem(input, binding_id) {
    if(binding_id === "game") {
      return $game;
    } else if(binding_id === "scene") {
      return $game.current_scene;
    } else if(binding_id === "card") {
      const card_el = input.closest("div.card");
      return card_el.rez_card;
    } else {
      return $(binding_id);
    };
  }

  getBoundValue(input, boundRezElementId, boundAttrName) {
    const elem = this.getBoundElem(input, boundRezElementId);
    if(elem === undefined) {
      throw new Error(`Failed to find game element for attribute binding: ${boundRezElementId}`);
    }
    return elem.getAttribute(boundAttrName)
  }

  setBoundValue(input, boundRezElementId, boundAttrName, value) {
    const elem = this.getBoundElem(input, boundRezElementId);
    if(typeof(elem) == undefined) {
      throw new Error(`Failed to find game element for attribute binding: ${boundRezElementId}`);
    }
    elem.setAttribute(boundAttrName, value);
  }

  transformTextInput(view, input, binding_id, binding_attr) {
    const transformer = this;

    view.registerBinding(binding_id, binding_attr, function (value) {
      input.value = value;
    });

    input.value = this.getBoundValue(input, binding_id, binding_attr);
    input.addEventListener("input", function (evt) {
      transformer.setBoundValue(input, binding_id, binding_attr, evt.target.value);
    });
  }

  transformCheckboxInput(view, input, binding_id, binding_attr) {
    const transformer = this;

    view.registerBinding(binding_id, binding_attr, function (value) {
      input.checked = value;
    });
    input.checked = this.getBoundValue(input, binding_id, binding_attr);
    input.addEventListener("change", function (evt) {
      transformer.setBoundValue(input, binding_id, binding_attr, evt.target.checked);
    });
  }

  setRadioGroupValue(group_name, value) {
    const radios = document.getElementsByName(group_name);
    for (let radio of radios) {
      if (radio.value == value) {
        radio.checked = true;
      }
    }
  }

  trackRadioGroupChange(group_name, callback) {
    const radios = document.getElementsByName(group_name);
    for (let radio of radios) {
      radio.addEventListener("change", callback);
    }
  }

  transformRadioInput(view, input, binding_id, binding_attr) {
    const transformer = this;
    if (!view.hasBinding(binding_id, binding_attr)) {
      // We only need to bind the first radio in the group
      view.registerBinding(binding_id, binding_attr, function (value) {
        transformer.setRadioGroupValue(input.name, value);
      });
    }

    this.setRadioGroupValue(input.name, this.getBoundValue(input, binding_id, binding_attr));

    this.trackRadioGroupChange(input.name, function (evt) {
      transformer.setBoundValue(input, binding_id, binding_attr, evt.target.value);
    });
  }

  transformSelect(view, select, binding_id, binding_attr) {
    const transformer = this;

    view.registerBinding(binding_id, binding_attr, function (value) {
      select.value = value;
    });
    select.value = this.getBoundValue(select, binding_id, binding_attr);
    select.addEventListener("change", function (evt) {
      transformer.setBoundValue(select, binding_id, binding_attr, evt.target.value);
    });
  }

  transformElement(input, view) {
    const [binding_id, binding_attr] = this.decodeBinding(
      input.getAttribute("rez-bind")
    );

    if (input.type === "text" || input.type == "textarea") {
      this.transformTextInput(view, input, binding_id, binding_attr);
    } else if (input.type === "checkbox") {
      this.transformCheckboxInput(view, input, binding_id, binding_attr);
    } else if (input.type === "radio") {
      this.transformRadioInput(view, input, binding_id, binding_attr);
    } else if (
      input.type === "select-one" ||
      input.type === "select-multiple"
    ) {
      this.transformSelect(view, input, binding_id, binding_attr);
    } else {
      throw new Error(`Unsupported input type: ${input.type}`);
    }
  }
}

window.Rez.RezBindingTransformer = RezBindingTransformer;

//-----------------------------------------------------------------------------
// View
//-----------------------------------------------------------------------------

class RezView {
  #container;
  #layout;
  #layoutStack;
  #bindings;
  #receiver;
  #transformers;

  constructor(container_id, receiver, layout, transformers) {
    const container = document.getElementById(container_id);
    if(typeof(container) === "undefined") {
      throw Error(`Cannot get container |${container_id}|`);
    }

    this.#container = document.getElementById(container_id);
    this.#layout = layout;
    this.#layoutStack = [];
    this.#bindings = new Map();
    this.#receiver = receiver;
    this.#transformers = transformers ?? this.defaultTransformers();
  }

  get container() {
    return this.#container;
  }

  get layout() {
    return this.#layout;
  }

  set layout(layout) {
    this.#layout = layout;
  }

  get layoutStack() {
    return this.#layoutStack;
  }

  pushLayout(layout) {
    this.layoutStack.push(this.layout);
    this.layout = layout;
  }

  popLayout() {
    this.layout = this.layoutStack.pop();
  }

  addLayoutContent(content) {
    this.layout.addContent(content);
  }

  get bindings() {
    return this.#bindings;
  }

  get receiver() {
    return this.#receiver;
  }

  get transformers() {
    return this.#transformers;
  }

  render() {
    const html = this.layout.html();
    this.container.innerHTML = html;
  }

  defaultTransformers() {
    return [
      new RezEventLinkTransformer(this.receiver),
      new RezBlockTransformer(),
      new RezButtonTransformer(this.receiver),
      new RezFormTransformer(this.receiver),
      new RezInputTransformer(this.receiver),
      new RezEnterKeyTransformer(this.receiver),
      new RezBindingTransformer(this.receiver)
    ];
  }

  transform() {
    this.transformers.forEach((transformer) =>
      transformer.transformElements(this)
    );
  }

  hasBinding(binding_id, binding_attr) {
    return this.bindings.has(`${binding_id}.${binding_attr}`);
  }

  registerBinding(binding_id, binding_attr, callback) {
    this.bindings.set(`${binding_id}.${binding_attr}`, callback);
  }

  updateBoundControls(binding_id, binding_attr, value) {
    const callback = this.bindings.get(`${binding_id}.${binding_attr}`);
    if (typeof callback == "function") {
      callback(value);
    }
  }

  clearBindings() {
    this.bindings.clear();
  }

  update() {
    this.clearBindings();
    this.render();
    this.transform();
  }

  _copyInto(target) {
    target.#container = this.#container;
    target.#layout = this.#layout.copy();
    target.#layoutStack = this.#layoutStack.copy();
    target.#bindings = this.#bindings.copy();
    target.#receiver = this.#receiver;
    target.#transformers = this.#transformers;
  }

  copy() {
    const copiedView = new this.constructor();
    this._copyInto(copiedView);
    return copiedView;
  }
}

window.Rez.RezView = RezView;

  

  window.Rez.mixins = {};







  //-----------------------------------------------------------------------------
// Register expression filters
//-----------------------------------------------------------------------------




Rez.template_expression_filters = {
  
    
    
    eq: (v1, v2) => {return v1 === v2;},

    
    
    ne: (v1, v2) => {return !(v1 === v2);},

    
    
    gt: (n1, n2) => {return n1 > n2;},

    
    
    gte: (n1, n2) => {return n1 >= n2;},

    
    
    lt: (n1, n2) => {return n1 < n2;},

    
    
    lte: (n1, n2) => {return n1 <= n2;},

    
    
    bsel: (sel, options) => {return options[sel ? 0 : 1];},

    
    
    sel: (idx, options) => {return options[idx];},

    
    
    add: (n, x) => {return n+x;},

    
    
    sub: (n, x) => {return n-x;},

    
    
    mul: (n, x) => {return n*x;},

    
    
    div: (n, x) => {return n/x;},

    
    
    mod: (n, x) => {return n % x;},

    
    
    abs: (n) => {return Math.abs(n)},

    
    
    neg: (n) => {return -n;},

    
    
    inc: (n) => {return n+1;},

    
    
    dec: (n) => {return n-1;},

    
    
    round: (n, dp) => {return n.roundp(dp);},

    
    
    lpad: (n, padChar, length) => {
    return String(n).padStart(length, padChar);
  },

    
    
    rpad: (n, padChar, length) => {
    return String(n).padEnd(length, padChar);
  },

    
    
    ordinal: (n) => {return n.ordinal();},

    
    
    char_at: (s, i) => {return s.charAt(i);},

    
    
    string: (s) => {return ""+s;},

    
    
    append: (s, t) => {return s + t;},

    
    
    to_camel_case: (s) => {return s.toCamelCase();},

    
    
    trim: (s) => {return s.trim();},

    
    
    to_title_case: (s) => {return s.toTitleCase();},

    
    
    downcase: (s) => {return s.toLowerCase();},

    
    
    prepend: (s, t) => {return t + s;},

    
    
    upcase: (s) => {return s.toUpperCase();},

    
    
    pluralize: (s) => {return pluralize(s);},

    
    
    possessive: (s) => {return s.possessive();},

    
    
    split: (s, p) => {return s.split(p);},

    
    
    starts_with: (s, search) => {return s.startsWith(search);},

    
    
    ends_with: (s, search) => {return s.endsWith(search);},

    
    
    contains: (s, search) => {return s.includes(search);},

    
    
    quoted: (s) => {return `'${s}'`;},

    
    
    dquoted: (s) => {return `"${s}"`;},

    
    
    i_article: (s) => {
    const article = s.indefiniteArticle();
    return `${article} ${s}`;
  },

    
    
    length: (arr) => {return arr.length;},

    
    
    take: (arr, n) => {return arr.take(n);},

    
    
    at: (arr, n) => {return arr[n];},

    
    
    event: (event, title) => {
    return "<a href='javascript:void(0);' class='event' data-event='" + event + "'>" + title + "</a>";
  },

    
    
    dyn_link: (card, action) => {
    const link_handler = card.getAttribute(action);
    if(typeof(link_handler) != "function") {
      throw `Attribute |${action}| of card |${card.id}| is not a handler function!`;
    } else {
      let link = new RezDynamicLink(card);
      link_handler(link);
      if(!link.choosen) {
        throw new Error("Choice must call one of hide/deny/allow!");
      }
      if(link.display) {
        return link.markup;
      } else {
        return "";
      }
    }
  },

    
    
    render: (source_obj, attribute, parent_block) => {
    const template = source_obj.getAttribute(attribute);
    if(typeof(template) === "undefined") {
      throw `Unable to render ${attribute} of ${source_obj.id} as it is not defined`;
    } else if(typeof(template) === "string") {
      return template;
    } else {
      const render_source = new RezSyntheticSource(template);
      const sub_block = new RezBlock("block", render_source);
      sub_block.parent_block = parent_block;
      return sub_block.renderBlock();
    }
  },

};

  //-----------------------------------------------------------------------------
// Initialize Game Objects
//-----------------------------------------------------------------------------






const game = new RezGame(
  "game",
  {"$flash_messages": [],
"$global": true,
"$init_order": ["asset_source_explorer_html", "_PLURALIZE_JS", "$load_game", "$load_game_form", "$actor_behaviours", "$select", "$select_r", "$select_p", "$sequence", "$loop", "$loop_until", "$maybe", "$either", "$random_choice", "$random_each", "$always", "$never", "$invert", "$fail", "$succeed", "_ALPINE_JS", "_BULMA_CSS", "sc_main", "c_intro"],
"$layout_template": function(bindings) {return [function(bindings) {return `<div id="game" data-game=true class="rez-game"><!-- Main Content -->
<section class="main-content is-fullheight">
<div class="container">`;},function(bindings) {return (function(bindings) {return bindings.content;})(bindings);},function(bindings) {return `</div>
</section>
<!-- End -->
</div>`;}].reduce(function(text, f) {return text + f(bindings)}, "");},
"$mixins": [],
"$scene_stack": [],
"IFID": "45BBD19C-CA0B-11F0-94B1-CA41670CF0BA",
"archive_format": 1,
"author": "Mr Sandbags & HAL-9000",
"author_email": "self@mattmower.com",
"created": "2025-11-25 14:30:21.191257Z",
"current_scene_id": "",
"game_homepage": "https://rez-lang.com/",
"initial_scene_id": {$ref: "sc_main"},
"name": "slipstream",
"start_events": [],
"title": "Slipstream",
"version": "1.0"}
)
;

RezBasicObject.game = game;

/* Encode game objects */
let el;

  el = new RezAsset(
  "asset_source_explorer_html",
  {"$detected_mime_type": "text/html",
"$dist_path": "assets/source_explorer.html",
"$source_path": "assets/source_explorer/source_explorer.html",
"file_name": "source_explorer.html"}
)
;
  game.addGameObject(el);
  

  el = new RezAsset(
  "_PLURALIZE_JS",
  {"$auto_id_idx": 0,
"$built_in": true,
"$detected_mime_type": "text/javascript",
"$dist_path": "assets/pluralize.js",
"$global": false,
"$inline": false,
"$js_defer": false,
"$js_runtime": false,
"$mixins": [],
"$pre_runtime": true,
"$source_path": "assets/js/pluralize.js",
"$template": false,
"file_name": "pluralize.js"}
)
;
  game.addGameObject(el);
  

  el = new RezScene(
  "$load_game",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$layout_template": function(bindings) {return [function(bindings) {return `<div id="scene_$load_game" data-scene="$load_game" class="rez-scene">`;},function(bindings) {return (function(bindings) {return bindings.content;})(bindings);},function(bindings) {return `
</div>`;}].reduce(function(text, f) {return text + f(bindings)}, "");},
"$mixins": [],
"$running": false,
"$template": false,
"current_card_id": "",
"initial_card_id": {$ref: "$load_game_form"},
"last_card_id": "",
"layout_mode": "single",
"layout_reverse": false,
"layout_separator": ""}
)
;
  game.addGameObject(el);
  

  el = new RezCard(
  "$load_game_form",
  {"$auto_id_idx": 0,
"$built_in": true,
"$content_template": function(bindings) {return [function(bindings) {return `<div id="card_$load_game_form" data-card="$load_game_form" class="rez-front-face"><form rez-live name="load_form">
<input type="file" name="data"/>
<input type="submit"/>
</form>
</div>`;}].reduce(function(text, f) {return text + f(bindings)}, "");},
"$flipped": false,
"$global": false,
"$mixins": [],
"$suppress_wrapper": false,
"$template": false,
"on_load_form": (card, data) => {
    console.log("In the load form handler!");
    const form = data.form;
    const file_input = form.querySelector("input[type=file]");
    const [file] = file_input.files;
    const reader = new FileReader();
    reader.addEventListener("load", function() {
      $game.load(reader.result);
    });
    reader.readAsText(file);
    return RezEvent.noop();
  }}
)
;
  game.addGameObject(el);
  

  el = new RezSystem(
  "$actor_behaviours",
  {"$built_in": true,
"$global": true,
"$mixins": [],
"after_event": (system, evt, result) => {
    if(evt.target.dataset.event === "behaviours") {
      console.log("Running actor_behaviours system");
      const game = evt.game;
      const actors = game.getAll("actor").filter((actor) => {return actor.hasAttribute("behaviours")});
      actors.forEach((actor) => {
        const btree = actor.getAttributeValue("behaviours");
        btree.executeBehaviour();
      });
    }
    return result;
  },
"enabled": false,
"priority": 10}
)
;
  game.addGameObject(el);
  
    window.$$actor_behaviours = el;
  

  el = new RezBehaviour(
  "$select",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    for(const child of behaviour.children) {
      if(child.executeBehaviour()) {
        return true;
      }
    }
    return false;
  },
"max_children": 0,
"min_children": 2,
"options": [],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$select_r",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    const indices = Math.range(0, behaviour.childCount-1).fy_shuffle();
    for(const i of indices) {
      const child = behaviour.getChildAt(i);
      if(child.executeBehaviour()) {
        return true;
      }
    }
    return false;
  },
"max_children": 0,
"min_children": 2,
"options": [],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$select_p",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"configure": (behaviour) => {
    const p = behaviour.intOption("p");
    if(p < 0 || p > 100) {
      throw "Behaviour: " + behaviour.id + " invalid 'p' option specified.";
    }
  },
"execute": (behaviour) => {
    const p = behaviour.intOption("p");
    const die = new RezDie(1, 100, 0);
    for(const child of behaviour.children) {
      if(die.roll() < p) {
        if(child.executeBehaviour()) {
          return true;
        }
      }
    }
    return false;
  },
"max_children": 0,
"min_children": 2,
"options": ["p"],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$sequence",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    for(const child of behaviour.children) {
      if(!child.executeBehaviour()) {
        return false;
      }
    }
    return true;
  },
"max_children": 0,
"min_children": 2,
"options": [],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$loop",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    const count = behaviour.intOption("count");
    for(let i=0; i<count; i++) {
      if(!behaviour.firstChild.executeBehaviour()) {
        return false;
      }
    }
    return true;
  },
"max_children": 1,
"min_children": 1,
"options": ["count"],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$loop_until",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    const attempts = behaviour.intOption("attempts");
    for(let i=0; i<attempts; i++) {
      if(behaviour.firstChild.executeBehaviour()) {
        return true;
      }
    }
    return false;
  },
"max_children": 1,
"min_children": 1,
"options": ["attempts"],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$maybe",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    const p = behaviour.intOption("p");
    const die = new RezDie(1, 100, 0);

    if(die.roll() < p) {
      return behaviour.firstChild.executeBehaviour();
    } else {
      return false;
    }
  },
"max_children": 1,
"min_children": 1,
"options": ["p"],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$either",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    const p = behaviour.intOption("p");
    const die = new RezDie(1, 100, 0);
    const roll = die.roll();

    if(roll < p) {
      return behaviour.firstChild.executeBehaviour();
    } else {
      return behaviour.secondChild.executeBehaviour();
    }
  },
"max_children": 2,
"min_children": 2,
"options": ["p"],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$random_choice",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    const die = new RezDie(1, behaviour.childCount, -1);
    const child = behaviour.getChildAt(die.roll());
    return child.executeBehaviour();
  },
"max_children": 0,
"min_children": 2,
"options": [],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$random_each",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    const stateKey = `behavior_${behaviour.id}_state`;
    let child_walk = behaviour.owner.getAttribute(stateKey);

    if(typeof(child_walk) == "undefined" || child_walk.length == 0) {
      child_walk = Array.from(Array(behaviour.childCount).keys()).fy_shuffle();
    }

    const child_idx = child_walk.shift();
    behaviour.owner.setAttribute(stateKey, child_walk);

    const child = behaviour.getChildAt(child_idx);
    return child.executeBehaviour();
  },
"max_children": 0,
"min_children": 2,
"options": [],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$always",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    behaviour.firstChild.executeBehaviour();
    return true;
  },
"max_children": 1,
"min_children": 1,
"options": [],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$never",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    behaviour.firstChild.executeBehaviour();
    return false;
  },
"max_children": 1,
"min_children": 1,
"options": [],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$invert",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    return !behaviour.firstChild.executeBehaviour();
  },
"max_children": 1,
"min_children": 1,
"options": [],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$fail",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    return false;
  },
"max_children": 0,
"min_children": 0,
"options": [],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezBehaviour(
  "$succeed",
  {"$auto_id_idx": 0,
"$built_in": true,
"$global": false,
"$mixins": [],
"$template": true,
"execute": (behaviour) => {
    return true;
  },
"max_children": 0,
"min_children": 0,
"options": [],
"owner_id": ""}
)
;
  game.addGameObject(el);
  

  el = new RezAsset(
  "_ALPINE_JS",
  {"$auto_id_idx": 0,
"$built_in": true,
"$detected_mime_type": "text/javascript",
"$dist_path": "assets/alpinejs.min.js",
"$global": false,
"$inline": false,
"$js_defer": true,
"$js_runtime": false,
"$mixins": [],
"$pre_runtime": true,
"$source_path": "assets/js/alpinejs.min.js",
"$template": false,
"file_name": "alpinejs.min.js",
"wuggle": true}
)
;
  game.addGameObject(el);
  

  el = new RezAsset(
  "_BULMA_CSS",
  {"$auto_id_idx": 0,
"$built_in": true,
"$detected_mime_type": "text/css",
"$dist_path": "assets/bulma.min.css",
"$global": false,
"$inline": false,
"$js_defer": false,
"$js_runtime": false,
"$mixins": [],
"$pre_runtime": false,
"$source_path": "assets/css/bulma.min.css",
"$template": false,
"file_name": "bulma.min.css"}
)
;
  game.addGameObject(el);
  

  el = new RezScene(
  "sc_main",
  {"$auto_id_idx": 0,
"$global": false,
"$layout_template": function(bindings) {return [function(bindings) {return `<div id="scene_sc_main" data-scene="sc_main" class="rez-scene">`;},function(bindings) {return (function(bindings) {return bindings.content;})(bindings);},function(bindings) {return `
</div>`;}].reduce(function(text, f) {return text + f(bindings)}, "");},
"$mixins": [],
"$running": false,
"$template": false,
"current_card_id": "",
"initial_card_id": {$ref: "c_intro"},
"last_card_id": "",
"layout_mode": "single",
"layout_reverse": false,
"layout_separator": ""}
)
;
  game.addGameObject(el);
  

  el = new RezCard(
  "c_intro",
  {"$auto_id_idx": 0,
"$content_template": function(bindings) {return [function(bindings) {return `<div id="card_c_intro" data-card="c_intro" class="rez-front-face"><section class="hero">
<div class="hero-body">
<p class="title">`;},function(bindings) {return (function(bindings) {return bindings.card.game.title;})(bindings);},function(bindings) {return `</p>
<p class="subtitle">From <span class="has-text-primary">`;},function(bindings) {return (function(bindings) {return bindings.card.game.author;})(bindings);},function(bindings) {return `</span></p>
</div>
<div class="box">
<p>Start adding your contentâ€¦</p>
<p>Explore the <a target="_blank" href="assets/source_explorer.html">source</a>.</p>
<p>See the <a href="http://rez-lang.com/" target="_blank">online documentation</a> for more information.</p>
</div>
</section>
</div>`;}].reduce(function(text, f) {return text + f(bindings)}, "");},
"$flipped": false,
"$global": false,
"$mixins": [],
"$suppress_wrapper": false,
"$template": false}
)
;
  game.addGameObject(el);
  


  

// Bind keyboard event generators
function rez_keybinding_listener(event) {
  const targetTag = event.target.tagName.toLowerCase();

  // Exclude all form input elements from global key bindings
  if(targetTag === "input" || targetTag === "textarea") {
    return;
  }

  const ep = $game.eventProcessor;
  let pred;


}

document.addEventListener("keydown", rez_keybinding_listener);

  window.Rez.user_components = {};




  window.Rez.user_components.embed_card = (bindings, assigns, content) => {
  let blockSource;
  if(typeof(assigns.card) === "string") {
    // We expect the id of a card
    blockSource = $t(assigns.card, "card", true);
  } else if(typeof(assigns.card) === "object" && assigns.card instanceof RezCard) {
    // Otherwise it should be a reference to a card
    blockSource = assigns.card;
  } else {
    throw new Error(`Attempt to embed card with bad 'card' assign! (${typeof(assigns.card)})`);
  }
  blockSource.$parent = bindings.card;
  const block = new RezBlock("block", blockSource);
  block.parentBlock = bindings.card.parentBlock;
  return block.html();
};

  window.Rez.user_components.img = (bindings, assigns, content) => {
  const asset = $(assigns["name"]);
  const path = asset.$dist_path;

  // Use assigns width/height if provided, otherwise use asset dimensions
  const w = assigns["width"] || asset.width;
  const h = assigns["height"] || asset.height;

  // Extract name, width and height from assigns so we don't duplicate them
  const { name, width, height, ...otherAssigns } = assigns;

  // Build additional attributes string from remaining assigns
  const otherAttributes = Object.entries(otherAssigns)
    .map(([key, value]) => `${key}="${value}"`)
    .join(" ");

  return `<img src="${path}" width="${w}" height="${h}" ${otherAttributes} />`;
};



  window.$ = (id, show_throw = false) => game.getGameObject(id, show_throw);
  window.$t = (id, element, should_throw = false) => game.getTypedGameObject(id, element, should_throw);

  /* @function isElementRef
   * @memberof RezGame
   * @param {*} value value to check
   * @returns {boolean} true if value is an element reference object
   * @description checks if a value is an element reference in {$ref: "id"} format
   */
  Rez.isElementRef = function(value) {
    return value && typeof value === 'object' && '$ref' in value;
  };

  /**
   * @function extractId
   * @memberof RezGame
   * @param {string|object} idOrRef either a string ID or a {$ref: "id"} object
   * @returns {string} the extracted ID string
   * @description extracts ID from either plain string or {$ref: "id"} format
   */
  Rez.extractId = function(idOrRef) {
    if (typeof idOrRef === 'string') return idOrRef;
    if (idOrRef?.$ref) return idOrRef.$ref;
    throw new Error(`Invalid reference format: ${String(idOrRef)}`);
  };

  window.$game = game;

  window.range = function*(sv, ev) {
    for(let ix = sv; ix <= ev; ix += 1) {
      yield ix;
    }
  }

  if(window.$game.getAttributeValue("$warn_before_reload", false)) {
    window.addEventListener("beforeunload", function(evt) {
      evt.preventDefault();
      evt.returnValue = "";
    });
  }
})();
