<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Source Explorer</title>
  <link rel="stylesheet" href="../css/bulma.min.css">
  <script defer src="../js/alpinejs.min.js"></script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }
    .explorer-container {
      display: flex;
      height: 100vh;
    }
    .file-sidebar {
      width: 280px;
      min-width: 280px;
      height: 100vh;
      overflow-y: auto;
      background-color: #f5f5f5;
      border-right: 1px solid #dbdbdb;
      padding: 1rem;
    }
    .file-sidebar .menu-label {
      color: #7a7a7a;
      font-size: 0.75rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-top: 1em;
    }
    .file-sidebar .menu-label:first-child {
      margin-top: 0;
    }
    .file-sidebar .menu-list a {
      padding: 0.5em 0.75em;
      border-radius: 4px;
      color: #4a4a4a;
      font-size: 0.9rem;
    }
    .file-sidebar .menu-list a:hover {
      background-color: #e8e8e8;
      color: #363636;
    }
    .file-sidebar .menu-list a.is-active {
      background-color: #3273dc;
      color: #fff;
    }
    .code-panel {
      flex: 1;
      height: 100vh;
      overflow-y: auto;
      padding: 1.5rem;
      background-color: #fff;
    }
    .code-container {
      background-color: #282c34;
      border-radius: 6px;
      padding: 1rem;
      overflow-x: auto;
    }
    .code-container pre {
      margin: 0;
      padding: 0;
      background: transparent;
    }
    .code-container code {
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Droid Sans Mono', 'Source Code Pro', monospace;
      font-size: 0.875rem;
      line-height: 1.6;
      color: #abb2bf;
      white-space: pre;
      tab-size: 2;
    }
    .explorer-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #363636;
      padding-bottom: 1rem;
      margin-bottom: 0.5rem;
      border-bottom: 1px solid #dbdbdb;
    }
  </style>
</head>

<body x-data="sourceExplorer()">

<div class="explorer-container">
  <!-- LEFT: File list sidebar -->
  <aside class="file-sidebar">
    <h1 class="explorer-title">Source Explorer</h1>
    <nav class="menu">
          <p class="menu-label">lib</p>
          <ul class="menu-list">
            <li>
              <a href="#" @click.prevent="select('lib/stdlib.rez')"
                 :class="selected === 'lib/stdlib.rez' ? 'is-active' : ''">
                stdlib.rez
              </a>
            </li>
          </ul>
          <p class="menu-label">src</p>
          <ul class="menu-list">
            <li>
              <a href="#" @click.prevent="select('src/player.rez')"
                 :class="selected === 'src/player.rez' ? 'is-active' : ''">
                player.rez
              </a>
            </li>
            <li>
              <a href="#" @click.prevent="select('src/scenes.rez')"
                 :class="selected === 'src/scenes.rez' ? 'is-active' : ''">
                scenes.rez
              </a>
            </li>
          </ul>
          <p class="menu-label">scenes</p>
          <ul class="menu-list">
            <li>
              <a href="#" @click.prevent="select('src/scenes/char_sheet.rez')"
                 :class="selected === 'src/scenes/char_sheet.rez' ? 'is-active' : ''">
                char_sheet.rez
              </a>
            </li>
          </ul>
          <p class="menu-label">src</p>
          <ul class="menu-list">
            <li>
              <a href="#" @click.prevent="select('src/slipstream.rez')"
                 :class="selected === 'src/slipstream.rez' ? 'is-active' : ''">
                slipstream.rez
              </a>
            </li>
          </ul>
    </nav>
  </aside>

  <!-- RIGHT: Code viewer -->
  <main class="code-panel">
    <div class="code-container">
      <pre><code x-text="sources[selected]"></code></pre>
    </div>
  </main>
</div>

<script>
function sourceExplorer() {
  return {
    sources: {"lib/stdlib.rez": "%% \n%% Autogenerated with Rez v1.8.7\n%% ** Do not modify as local changes will be overwritten every time the game is compiled **\n\n%% ----------------------------------------------------------------------------\n%% Defaults\n%% ----------------------------------------------------------------------------\n\n@defaults actor {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n}\n\n@schema actor {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :ref}\n  $js_ctor: {kind: :string}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  container_id: {kind: :elem_ref, ref_elem: @inventory}\n  on_accept_item: {kind: :function, params: [actor event]}\n  on_enter: {kind: :function, params: [actor event]}\n  on_leave: {kind: :function, params: [actor event]}\n  on_turn: {kind: :function, params: [actor event]}\n  behaviours: {kind: :bht}\n}\n\n@defaults asset {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n  $js_runtime: false\n  $js_defer: false\n  $pre_runtime: false\n  $inline: false\n}\n\n@schema asset {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :ref}\n  $js_ctor: {kind: :set, coll_kind: :keyword}\n  $js_runtime: {kind: :boolean}\n  $js_defer: {kind: :boolean}\n  $pre_runtime: {kind: :boolean}\n  $inline: {kind: :boolean}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  file_name: {kind: :string, xor: file_path}\n  file_path: {kind: :string, xor: file_name, file_exists}\n  width: {kind: [:string :number], and: height}\n  height: {kind: [:string :number], and: width}\n}\n\n@defaults behaviour {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n\n  options: []\n  min_children: 0\n  max_children: 0\n  owner_id: _\n}\n\n@schema behaviour {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :ref}\n  $js_ctor: {kind: :string}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  execute: {kind: :function, params: [behaviour], required: true}\n\n  options: {kind: :list, coll_kind: :keyword}\n  expected_keys: {kind: :list, coll_kind: :keyword}\n  min_children: {kind: :number}\n  max_children: {kind: :number}\n  owner_id: {kind: :elem_ref}\n}\n\n@defaults card {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n  $flipped: false\n  $suppress_wrapper: false\n}\n\n@schema card {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :ref}\n  $js_ctor: {kind: :string}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  content: {kind: :source_template, required: true}\n  flipped_content: {kind: :source_template}\n\n  $flipped: {kind: :boolean}\n  $suppress_wrapper: {kind: :boolean}\n\n  bindings: {kind: :list, coll_kind: :list_binding}\n  blocks: {kind: :list, coll_kind: :elem_ref, ref_elem: @card}\n  css_class: {kind: :string}\n\n  on_start: {kind: :function}\n  on_finish: {kind: :function}\n  on_render: {kind: :function}\n}\n\n@defaults effect {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n}\n\n@schema effect {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n  $js_ctor: {kind: :string}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  on_apply: {kind: :function}\n  on_remove: {kind: :function}\n}\n\n@defaults faction {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n}\n\n@schema faction {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n  $js_ctor: {kind: :string}\n\n  tags: {kind: :set, coll_kind: :keyword}\n}\n\n@schema filter {\n  name: {kind: :string, required: true}\n  impl: {kind: :function, required: true}\n}\n\n@defaults game {\n  $global: true\n  $scene_stack: []\n  $flash_messages: []\n  start_events: []\n\n  current_scene_id: _\n  layout: ```\n  ${content}\n  ```\n}\n\n@schema game {\n  $global: {kind: :boolean}\n  $template: {allowed: false}\n  $js_ctor: {kind: :string}\n  $scene_stack: {kind: :list}\n  $flash_messages: {kind: :list}\n  start_events: {kind: :list, coll_kind: :list_binding}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  name: {kind: :string, required: true}\n  title: {kind: :string, required: true}\n  author: {kind: :string, required: true}\n  author_email: {kind: :string}\n  archive_format: {kind: :number, required: true}\n  layout: {kind: :source_template, required: true, contains: \"${content}\"}\n  initial_scene_id: {kind: :elem_ref, ref_elem: @scene, required: true}\n  IFID: {kind: :string, required: true}\n\n  current_scene_id: {kind: :elem_ref}\n\n  bindings: {kind: :list, coll_kind: :list_binding}\n  blocks: {kind: :list, coll_kind: :elem_ref, ref_elem: @card}\n  links: {kind: :list, coll_kind: :string}\n  scripts: {kind: :list, coll_kind: :string}\n\n  on_init: {kind: :function}\n  on_start: {kind: :function}\n  on_save: {kind: :function}\n  on_load: {kind: :function}\n}\n\n@defaults generator {\n  $global: false\n  $template: false\n\n  customize: (obj) => {return obj;}\n}\n\n@schema generator {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  priority: {kind: :number, min: 1, max: 100, required: true}\n  source: {kind: :elem_ref, required: true}\n  copies: {kind: :number, min: 0}\n\n  customize: {kind: :function}\n}\n\n@defaults group {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n}\n\n@schema group {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n  $js_ctor: {kind: :string}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  type: {kind: :keyword, in: [:image, :audio, :video], required: true}\n  include_tags: {kind: :set, coll_kind: :keyword, xor: exclude_tags}\n  exclude_tags: {kind: :set, coll_kind: :keyword, xor: include_tags}\n}\n\n@defaults inventory {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n\n  apply_effects: true\n}\n\n@schema inventory {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n  $js_ctor: {kind: :string}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  owner: {kind: :elem_ref}\n  slots: {kind: :set, coll_kind: :elem_ref, ref_elem: @slot, required: true, min_length: 1}\n  apply_effects: {kind: :boolean}\n\n  on_insert: {kind: :function}\n  on_remove: {kind: :function}\n\n  ?/^initial_/: {kind: :list, coll_kind: :elem_ref}\n}\n\n%% In Rez v1.8 we remove @item as a basic element and make it an alias of\n%% @card so that items can be used directly in rendering the interface. You\n%% can set the current card to an item to have it render itself.\n\n@elem item = card\n\n@defaults item {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n  is_item: true\n  type: :item\n}\n\n@schema item {\n  %% This does not preserve the item validation that determines whether the\n  %% type refers to an accept: for a slot\n  type: {kind: :keyword, required: true, is_a: @slot/accepts}\n\n  container: {kind: :elem_ref, ref_elem: @inventory}\n  size: {kind: :number, min: 0}\n  uses: {kind: :number, min: 0}\n  effects: {kind: :list, coll_kind: :elem_ref, ref_elem: @effect}\n  asset_id: {kind: :elem_ref, ref_elem: @asset}\n}\n\n@defaults list {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n}\n\n@schema list {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n  $js_ctor: {kind: :string}\n\n  values: {kind: :list, required: true}\n\n  tags: {kind: :set, coll_kind: :keyword}\n}\n\n@defaults object {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n}\n\n@schema object {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n  $js_ctor: {kind: :string}\n\n  tags: {kind: :set, coll_kind: :keyword}\n}\n\n@schema patch {\n  patch: {kind: :string, required: true}\n  impl: {kind: :function, required: true}\n\n  function: {kind: :string, xor: method}\n  method: {kind: :string, xor: function}\n}\n\n@defaults plot {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n\n  stage: 0\n  active: false\n}\n\n@schema plot {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n  $js_ctor: {kind: :string}\n\n  stage: {kind: :number}\n  active: {kind: :boolean}\n\n  stages: {kind: :number, min: 1, required: true}\n  priority: {kind: :number, min: 1, max: 100, required: true}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  on_begin: {kind: :function}\n  on_tick: {kind: :function}\n  on_complete: {kind: :function}\n}\n\n@defaults rel {\n  $global: false\n  $template: false\n}\n\n@schema rel {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n  $js_ctor: {kind: :string}\n\n  source_id: {kind: :ref, required: true}\n  target_id: {kind: :ref, required: true}\n\n  tags: {kind: :set, coll_kind: :keyword}\n}\n\n@defaults scene {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n  $running: false\n\n  current_card_id: _\n  last_card_id: _\n  layout: ```\n  ${content}\n  ```\n  layout_mode: :single\n  layout_separator: \"\"\n  layout_reverse: false\n}\n\n@schema scene {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n  $js_ctor: {kind: :string}\n  $running: {kind: :boolean}\n\n  initial_card_id: {kind: :elem_ref, ref_elem: @card, required: true}\n  current_card_id: {kind: :elem_ref}\n  last_card_id: {kind: :elem_ref}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  layout: {kind: :source_template, contains: \"${content}\"}\n  layout_mode: {kind: :keyword, in: [:single :stack]}\n  layout_separator: {kind: :string}\n  layout_reverse: {kind: :boolean}\n  bindings: {kind: :list, coll_kind: :list_binding}\n  blocks: {kind: :list, coll_kind: :elem_ref, ref_elem: @card}\n\n  on_init: {kind: :function}\n  on_start: {kind: :function}\n  on_finish: {kind: :function}\n  on_interrupt: {kind: :function}\n  on_resume: {kind: :function}\n  on_render: {kind: :function}\n  on_start_card: {kind: :function}\n  on_finish_card: {kind: :function}\n}\n\n@defaults slot {\n  $global: false\n  $template: false\n  $auto_id_idx: 0\n\n  apply_effects: true\n}\n\n@schema slot {\n  $global: {kind: :boolean}\n  $template: {kind: :boolean}\n  $auto_id_idx: {kind: :number}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n  $js_ctor: {kind: :string}\n\n  accepts: {kind: :keyword, required: true, type_exists}\n  accessor: {kind: :keyword, required: true}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  name: {kind: :string}\n  apply_effects: {kind: :boolean}\n\n  capacity: {kind: :number, min: 0}\n\n  on_insert: {kind: :function}\n  on_remove: {kind: :function}\n}\n\n@defaults system {\n  $global: true\n}\n\n@schema system {\n  $global: {kind: :boolean}\n  $template: {allowed: false}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n  $js_ctor: {kind: :string}\n\n  tags: {kind: :set, coll_kind: :keyword}\n\n  enabled: {kind: :boolean, required: true}\n  priority: {kind: :number, min: 0, required: true}\n\n  before_event: {kind: :function, param_count: 3, or: after_event}\n  after_event: {kind: :function, param_count: 3, or: before_event}\n}\n\n@defaults timer {\n  $global: false\n  $timer: \"\"\n\n  auto_start: true\n  repeats: true\n\n  on_game_started: (timer) => {if(timer.auto_start) {timer.run();}; return {handled: true};}\n  on_game_loaded: (timer) => {if(timer.auto_start) {timer.run();}; return {handled: true};}\n}\n\n@schema timer {\n  $global: {kind: :boolean}\n  $template: {allowed: false}\n  $init_after: {kind: :list, coll_kind: :elem_ref}\n  $js_ctor: {kind: :string}\n\n  $timer: {kind: :string}\n\n  interval: {kind: :number, min: 0, required: true}\n  event: {kind: :keyword, required: true} %% Could we support \'default: timer.id\' ?\n\n  auto_start: {kind: :boolean}\n  repeats: {kind: :boolean}\n  count: {kind: :number, min: 1}\n\n  on_game_started: {kind: :function}\n  on_game_loaded: {kind: :function}\n}\n\n%% ----------------------------------------------------------------------------\n%% Head Assets\n%% ----------------------------------------------------------------------------\n\n%% Moved these to the base_game template so that users can override\n\n@asset _PLURALIZE_JS {\n  $built_in: true\n  file_name: \"pluralize.js\"\n  $js_defer: false\n  $pre_runtime: true\n}\n\n%% ----------------------------------------------------------------------------\n%% JS Library Patches\n%% ----------------------------------------------------------------------------\n\n@script {\n  function isObject(obj) {\n    return obj !== null && typeof obj === \"object\" && Object.prototype.toString.call(obj) === \"[object Object]\";\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Boolean\"\n  function: \"rand\"\n  impl: function() {\n    return Math.random() < 0.5 ? true : false;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Object\"\n  method: \"copy\"\n  impl: function() {\n    const deepCopy = (value) => {\n      if(value === null || value === undefined || typeof(value) !== \'object\') {\n        return value;\n      } else if(typeof(value.copy) === \'function\') {\n        return value.copy();\n      } else {\n        return Object.copy.call(value);\n      }\n    };\n\n    // Handle null or undefined\n    if (this === null || typeof this === \'undefined\') {\n        return this;\n    }\n\n    if(this instanceof Set) {\n      return new Set([...this].map(item => deepCopy(item)));\n    }\n\n    // Handle array\n    if (Array.isArray(this)) {\n      return this.map(item => deepCopy(item));\n    }\n\n    // Handle object\n    if (typeof this === \'object\') {\n        // Use the same constructor as the original object to preserve prototype chain\n        let copiedObj;\n\n        try {\n            // Try to create a new instance using the constructor\n            copiedObj = new this.constructor();\n        } catch (e) {\n            // If constructor fails, fall back to creating object with same prototype\n            copiedObj = Object.create(Object.getPrototypeOf(this));\n        }\n\n        // Copy all enumerable properties\n        for (const key in this) {\n            if (this.hasOwnProperty(key)) {\n                copiedObj[key] = deepCopy(this[key]);\n            }\n        }\n\n        // Copy non-enumerable properties\n        Object.getOwnPropertyNames(this).forEach(key => {\n            if (!copiedObj.hasOwnProperty(key)) {\n                const descriptor = Object.getOwnPropertyDescriptor(this, key);\n                if (descriptor) {\n                    // For accessor properties (getters/setters), preserve them\n                    if (descriptor.get || descriptor.set) {\n                        Object.defineProperty(copiedObj, key, descriptor);\n                    } else {\n                        // For data properties, deep copy the value\n                        Object.defineProperty(copiedObj, key, {\n                            value: deepCopy(descriptor.value),\n                            writable: descriptor.writable,\n                            enumerable: descriptor.enumerable,\n                            configurable: descriptor.configurable\n                        });\n                    }\n                }\n            }\n        });\n\n        // Copy symbol properties\n        Object.getOwnPropertySymbols(this).forEach(sym => {\n            const descriptor = Object.getOwnPropertyDescriptor(this, sym);\n            if (descriptor) {\n                // For accessor properties (getters/setters), preserve them\n                if (descriptor.get || descriptor.set) {\n                    Object.defineProperty(copiedObj, sym, descriptor);\n                } else {\n                    // For data properties, deep copy the value\n                    Object.defineProperty(copiedObj, sym, {\n                        value: deepCopy(descriptor.value),\n                        writable: descriptor.writable,\n                        enumerable: descriptor.enumerable,\n                        configurable: descriptor.configurable\n                    });\n                }\n            }\n        });\n\n        return copiedObj;\n    }\n\n    // Handle other primitive types (e.g., string, number, etc.)\n    return this;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Object\"\n  method: \"objMap\"\n  impl: function(f) {\n    const entries = Object.entries(this);\n    const new_entries = entries.map(([k, v]) => [k, f(v, k)]);\n    return Object.fromEntries(new_entries);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  method: \"dqWrap\"\n  impl: function() {\n    return `\"${this}\"`;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"max\"\n  impl: function() {\n    if(this.length === 0) {\n      throw new Error(\"Cannot get the max of an empty array!\");\n    }\n\n    return this.reduce((a, b) => Math.max(a, b));\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"min\"\n  impl: function() {\n    if(this.length === 0) {\n      throw new Error(\"Cannot get the min of an empty array!\");\n    }\n\n    return this.reduce((a, b) => Math.min(a, b));\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"englishList\"\n  impl: function(amp) {\n    let connector = \"and\";\n    if(amp != undefined && amp) {\n      connector = \"&\";\n    }\n\n    switch(this.length) {\n      case 0:\n        return \"\";\n\n      case 1:\n        return `${this[0]}`;\n\n      case 2:\n        return this.join(` ${connector} `);\n\n      default:\n        return this.slice(0, -1).join(\", \") + `, ${connector} ` + this[this.length - 1];\n    }\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"remove\"\n  impl: function(elem) {\n    const idx = this.indexOf(elem);\n    if(idx !== -1) {\n      this.splice(idx, 1);\n    }\n    return this;\n  }\n}\n\n@patch {\n  $built_in: true\n  %% Fisher-Yates Shuffle impl from: https://sebhastian.com/fisher-yates-shuffle-javascript/\n  patch: \"Array\"\n  method: \"fyShuffle\"\n  impl: function() {\n    let idx = this.length;\n    while(--idx > 0) {\n      const rand_idx = Math.floor(Math.random() * (idx+1));\n      [this[rand_idx], this[idx]] = [this[idx], this[rand_idx]];\n    }\n    return this;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"randomElement\"\n  impl: function() {\n    return this.at(Math.floor(Math.random() * this.length));\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"randomIndex\"\n  impl: function() {\n    return Math.floor(Math.random() * this.length);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"frequencies\"\n  impl: function() {\n    const freqs = new Map();\n    for(const v of this) {\n      let val = freqs.get(v);\n      if(typeof(val) == \"undefined\") {\n        val = 1;\n      } else {\n        val = val + 1;\n      }\n      freqs.set(v, val);\n    }\n    return freqs;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"normalizePTable\"\n  impl: function() {\n    const sum = this.reduce((sum, [value, freq]) => sum + freq, 0);\n\n    let cumProbability = 0.0;\n    return this.map(([value, freq]) => {\n      cumProbability += freq/sum;\n      return [value, cumProbability];\n    });\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"sum\"\n  impl: function() {\n    return this.reduce((a, b) => a+b, 0);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  function: \"equals\"\n  impl: function(a, b) {\n    return Array.isArray(a) &&\n        Array.isArray(b) &&\n        a.length === b.length &&\n        a.every((val, index) => val === b[index]);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"startsWithSequence\"\n  impl: function(sequence) {\n    return this.slice(0, sequence.length).every((value, index) => value === sequence[index]);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"to_pairs\"\n  impl: function() {\n    let pairs = [];\n    for(let i = 0; i < this.length; i += 2) {\n      if(this[i + 1] !== undefined) {\n        pairs.push([this[i], this[i + 1]]);\n      }\n    }\n    return pairs;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"take\"\n  impl: function(n) {\n    if(this.length < n) {\n      throw `Cannot take ${n} items from an array containing ${this.length} items!`;\n    }\n\n    return Math.range(1, n).map((_) => {return this.shift()});\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"refs\"\n  impl: function() {\n    return this.map((id) => $(id));\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"ids\"\n  impl: function() {\n    return this.map((obj) => obj.id);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  function: \"nOf\"\n  impl: function(length, def_value) {\n    if(typeof(def_value) === \"function\") {\n      return Array.from({length: length}, def_value);\n    } else {\n      return Array.from({length: length}, () => def_value);\n    }\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"sample\"\n  impl: function(percentage) {\n    if (!Array.isArray(this) || this.length === 0 || percentage <= 0) {\n      return []; // Return an empty array for invalid input\n    }\n\n    const sampleSize = Math.ceil(this.length * (percentage / 100));\n    const result = [];\n    const indicesUsed = new Set();\n\n    while (result.length < sampleSize && indicesUsed.size < this.length) {\n      const randomIndex = Math.floor(Math.random() * this.length);\n      if (!indicesUsed.has(randomIndex)) {\n        indicesUsed.add(randomIndex);\n        result.push(this[randomIndex]);\n      }\n    }\n\n    return result;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  function: \"zip\"\n  impl: function(ar1, ar2) {\n    return ar1.map((value, idx) => [value, ar2[idx]]);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"splitWith\"\n  impl: function(pred) {\n    return this.reduce(\n        (acc, item) => {\n          acc[pred(item) ? 0 : 1].push(item);\n          return acc;\n        },\n        [[], []]\n      );\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Array\"\n  method: \"pushWithLimit\"\n  impl: function(el, lim) {\n    this.push(el);\n    if(this.length > lim) {\n      this.shift();\n    }\n    return this;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  method: \"beginsWithConsonant\"\n  impl: function() {\n    return /^[^aeiouAEIOU]/.test(this);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  method: \"beginsWithVowel\"\n  impl: function() {\n    return /^[aeiouAEIOU]/.test(string);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  method: \"toTitleCase\"\n  impl: function() {\n    return this.replace(/(^|\\s)\\S/g, l => l.toUpperCase());\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  method: \"possessive\"\n  impl: function() {\n    if(this.endsWith(\"s\")) {\n      return this + \"\'\";\n    } else {\n      return this + \"\'s\";\n    }\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  method: \"toCamelCase\"\n  impl: function() {\n    return this.replace(/[_.-](\\w|$)/g, function (_, x) {\n\t  \treturn x.toUpperCase();\n\t  });\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  method: \"toPascalCase\"\n  impl: function() {\n    const camelCase = this.replace(/[_.-](\\w|$)/g, function (_, x) {\n\t  \treturn x.toUpperCase();\n\t  });\n    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  method: \"toKebabCase\"\n  impl: function() {\n    return this\n      .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)\n      .map(x => x.toLowerCase())\n      .join(\'-\');\n  }\n}\n\n\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  method: \"toSnakeCase\"\n  impl: function() {\n      return this\n      .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)\n      .map(x => x.toLowerCase())\n      .join(\'_\');\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  method: \"parseTime\"\n  impl: function() {\n    const time_components = this.match( /(\\d+)(?::(\\d\\d))?\\s*(p?)/ );\n    const hour_s = time_components[1];\n    if(typeof(hour_s) == \"undefined\") {\n      throw \"Invalid time string (hour): \'\" + this + \"\'\";\n    }\n    const hour = parseInt(hour_s);\n    if(hour == NaN) {\n      throw \"Invalid time string (hour): \'\" + this + \"\'\";\n    }\n\n    const mins_s = time_components[2];\n    if(typeof(mins_s) == \"undefined\") {\n      throw \"Invalid time string (mins): \'\" + this + \"\'\";\n    }\n\n    const mins = parseInt(mins_s);\n    if(typeof(mins) == NaN) {\n      throw \"Invalid time string (mins): \'\" + this + \"\'\";\n    }\n\n    return [hour, mins];\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  function: \"randomId\"\n  impl: function() {\n    const rand = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    return rand.toString(16);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  method: \"wrapWith\"\n  impl: function(prefix, suffix) {\n    suffix = suffix ?? prefix;\n    return `${prefix}${this}${suffix}`;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"String\"\n  method: \"indefiniteArticle\"\n  impl: function() {\n    return this.beginsWithConsonant() ? \"a\" : \"an\";\n  }\n}\n\n%% Some helpful set functions from:\n%% https://medium.com/@alvaro.saburido/set-theory-for-arrays-in-es6-eb2f20a61848\n%% https://stackoverflow.com/a/31129384/7518\n\n@patch {\n  $built_in: true\n  patch: \"Set\"\n  method: \"union\"\n  impl: function(otherSet) {\n    return new Set([...this, ...otherSet]);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Set\"\n  method: \"intersection\"\n  impl: function(otherSet) {\n    return new Set([...this].filter(x => otherSet.has(x)));\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Set\"\n  method: \"difference\"\n  impl: function(otherSet) {\n    return new Set([...this].filter(x => !otherSet.has(x)));\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Set\"\n  method: \"equals\"\n  impl: function(otherSet) {\n    return this.size === otherSet.size &&\n    [...this].every((x) => otherSet.has(x));\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Set\"\n  method: \"hasSubset\"\n  impl: function(otherSet) {\n    return this.intersection(otherSet).equals(otherSet);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Number\"\n  method: \"ordinal\"\n  impl: function() {\n    const lastDigit = this % 10;\n    const secondLastDigit = Math.floor((this % 100) / 10);\n\n    if (lastDigit === 1 && secondLastDigit !== 1) {\n      return this + \'st\';\n    } else if (lastDigit === 2 && secondLastDigit !== 1) {\n      return this + \'nd\';\n    } else if (lastDigit === 3 && secondLastDigit !== 1) {\n      return this + \'rd\';\n    } else {\n      return this + \'th\';\n    }\n  }\n}\n\n@patch {\n  $built_in: true\n  %% https://stackoverflow.com/questions/7342957/how-do-you-round-to-1-decimal-place-in-javascript\n  patch: \"Number\"\n  method: \"roundp\"\n  impl: function(precision) {\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(this * multiplier) / multiplier;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Number\"\n  method: \"cl_avg\"\n  impl: function(rounds) {\n    rounds ??= 2;\n    const f = Math.random() < 0.5 ? Math.ceil : Math.floor;\n    return f(this/rounds);\n  }\n}\n\n@patch {\n  $built_in: true\n  %% rounds a number to the nearest 0.5\n  patch: \"Number\"\n  method: \"r2nh\"\n  impl: function() {\n    return Math.round(this * 2) / 2;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Number\"\n  method: \"dist_round\"\n  impl: function() {\n    return Math.dist_round(this);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Number\"\n  method: \"round_to_nearest\"\n  impl: function(n) {\n    if(n === 0) {\n      return this;\n    } else {\n      return Math.round(this / n) * n;\n    }\n  }\n}\n\n@patch {\n  %% See Array.nOf() for creating arrays with n items\n  $built_in: true\n  patch: \"Number\"\n  method: \"times\"\n  impl: function(f) {\n    for(let ix = 0; ix < this; ix++) {\n      f(ix);\n    }\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"perc\"\n  impl: function(p) {\n    return Math.random() <= (p/100);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"div\"\n  impl: function(n, d) {\n    return Math.floor(n/d);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"div_mod\"\n  impl: function(n, d) {\n    const div = Math.floor(n/d);\n    const mod = n % d;\n    return [div, mod];\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"range\"\n  impl: function(from, to, step) {\n    step ??= 1;\n\n    if(from>to) {\n      [from, to] = [to, from];\n    }\n\n    return Array.from(\n      {length: (to-from)/step+1},\n      (_, i) => from + (i * step));\n  }\n}\n\n@patch {\n  $built_in: true\n  %% Because JS only gives us random numbers as floating point we sometimes\n  %% end up having to round when we want an integer. The question is whether we round\n  %% up or round down which can create a bias. The dist_round function randomly\n  %% round up or down to distribute values evenly.\n  patch: \"Math\"\n  function: \"dist_round\"\n  impl: function(v) {\n    if(Math.random() < 0.5) {\n      return Math.ceil(v);\n    } else {\n      return Math.floor(v);\n    }\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"rand_int\"\n  impl: function(lim) {\n    return Math.floor(Math.random() * lim);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"rand_int_between\"\n  impl: function(min, max) {\n    if(min > max) {\n      [min, max] = [max, min]\n    }\n    return Math.floor(min + Math.random() * (max - min + 1));\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"rand_f_between\"\n  impl: function(min, max) {\n    if(min > max) {\n      [min, max] = [max, min]\n    }\n\n    return min + (Math.random() * (max - min));\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"cl_rand_f_between\"\n  impl: function(min, max, rounds) {\n    rounds = rounds ?? 2;\n    let total = 0;\n    for(let i = 0; i < rounds; i+= 1) {\n      total += Math.rand_f_between(min, max);\n    }\n    return total/rounds;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"cl_rand_int\"\n  impl: function(lim) {\n    const v1 = Math.rand_int(lim);\n    const v2 = Math.rand_int(lim);\n    return (v1+v2)/2;\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"cl_rand_int_between\"\n  impl: function(lo, hi) {\n    const v1 = Math.rand_int_between(lo, hi);\n    const v2 = Math.rand_int_between(lo, hi);\n    return Math.dist_round((v1+v2)/2);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"clamped_sub\"\n  impl: function(value, sub, min) {\n    return Math.max(value-sub, min);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"clamped_add\"\n  impl: function(value, add, max) {\n    return Math.min(value+add, max);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"alter\"\n  impl: function(value, change, min, max) {\n    return Math.max(Math.min(value+change, max), min);\n  }\n}\n\n@patch {\n  $built_in: true\n  patch: \"Math\"\n  function: \"samplePTable\"\n  impl: function(table) {\n    if(!Array.isArray(table)) {\n      throw new Error(`Tried to sample an ${typeof(table)} which is expected be an array [[value, prob], [value, prob], ...]`);\n    }\n\n    const p = Math.random();\n    const idx = table.findIndex((pair) => p <= pair[1]);\n    if (idx == -1) {\n      throw new Error(\"Invalid p_table. Must contain range 0<n<1\");\n    }\n    return table[idx][0];\n  }\n}\n\n%% ----------------------------------------------------------------------------\n%% Template Filters\n%% ----------------------------------------------------------------------------\n\n@filter COMPARE_EQ_FILTER {\n  $built_in: true\n\n  %% v -> v -> bool\n  name: \"eq\"\n  impl: (v1, v2) => {return v1 === v2;}\n}\n\n@filter COMPARE_NE_FILTER {\n  $built_in: true\n\n  %% v -> v -> bool\n  name: \"ne\"\n  impl: (v1, v2) => {return !(v1 === v2);}\n}\n\n@filter COMPARE_GT_FILTER {\n  $built_in: true\n\n  %% n -> n -> bool\n  name: \"gt\"\n  impl: (n1, n2) => {return n1 > n2;}\n}\n\n@filter COMPARE_GTE_FILTER {\n  $built_in: true\n\n  %% n -> n -> bool\n  name: \"gte\"\n  impl: (n1, n2) => {return n1 >= n2;}\n}\n\n@filter COMPARE_LT_FILTER {\n  $built_in: true\n\n  %% n -> n -> bool\n  name: \"lt\"\n  impl: (n1, n2) => {return n1 < n2;}\n}\n\n@filter COMPARE_LTE_FILTER {\n  $built_in: true\n\n  %% n -> n -> bool\n  name: \"lte\"\n  impl: (n1, n2) => {return n1 <= n2;}\n}\n\n@filter BSEL_FILTER {\n  $built_in: true\n\n  %% bool -> array -> any\n  name: \"bsel\"\n  impl: (sel, options) => {return options[sel ? 0 : 1];}\n}\n\n@filter SEL_FILTER {\n  $built_in: true\n\n  %% n -> array -> any\n  name: \"sel\"\n  impl: (idx, options) => {return options[idx];}\n}\n\n@filter ADD_FILTER {\n  $built_in: true\n\n  %% n -> n\n  name: \"add\"\n  impl: (n, x) => {return n+x;}\n}\n\n@filter SUB_FILTER {\n  $built_in: true\n\n  %% n -> n\n  name: \"sub\"\n  impl: (n, x) => {return n-x;}\n}\n\n@filter MUL_FILTER {\n  $built_in: true\n\n  %% n -> n\n  name: \"mul\"\n  impl: (n, x) => {return n*x;}\n}\n\n@filter DIV_FILTER {\n  $built_in: true\n\n  %% n -> n\n  name: \"div\"\n  impl: (n, x) => {return n/x;}\n}\n\n@filter MOD_FILTER {\n  $built_in: true\n\n  %% n -> n\n  name: \"mod\"\n  impl: (n, x) => {return n % x;}\n}\n\n@filter ABS_FILTER {\n  $built_in: true\n\n  %% n -> n\n  name: \"abs\"\n  impl: (n) => {return Math.abs(n)}\n}\n\n@filter NEG_FILTER {\n  $built_in: true\n\n  %% n -> n\n  name: \"neg\"\n  impl: (n) => {return -n;}\n}\n\n@filter INC_FILTER {\n  $built_in: true\n\n  %% n -> n\n  name: \"inc\"\n  impl: (n) => {return n+1;}\n}\n\n@filter DEC_FILTER {\n  $built_in: true\n\n  %% n -> n\n  name: \"dec\"\n  impl: (n) => {return n-1;}\n}\n\n@filter ROUND_FILTER {\n  $built_in: true\n\n  %% n -> n\n  name: \"round\"\n  impl: (n, dp) => {return n.roundp(dp);}\n}\n\n@filter LPAD_FILTER {\n  $built_in: true\n\n  %% n, p, c -> \"(m*s)n\"\n  name: \"lpad\"\n  impl: (n, padChar, length) => {\n    return String(n).padStart(length, padChar);\n  }\n}\n\n@filter RPAD_FILTER {\n  $built_in: true\n\n  name: \"rpad\"\n  impl: (n, padChar, length) => {\n    return String(n).padEnd(length, padChar);\n  }\n}\n\n@filter ORDINAL_FILTER {\n  $built_in: true\n\n  %% n -> \"n(st|nd|rd|th)\"\n  name: \"ordinal\"\n  impl: (n) => {return n.ordinal();}\n}\n\n@filter STRING_CHAR_AT_FILTER {\n  $built_in: true\n\n  %% String -> String\n  name: \"char_at\"\n  impl: (s, i) => {return s.charAt(i);}\n}\n\n@filter STRING_MAKE_FILTER {\n  $built_in: true\n\n  %% any -> String\n  name: \"string\"\n  impl: (s) => {return \"\"+s;}\n}\n\n@filter STRING_APPEND_FILTER {\n  $built_in: true\n\n  %% String -> String\n  name: \"append\"\n  impl: (s, t) => {return s + t;}\n}\n\n@filter STRING_TO_CAMEL_CASE_FILTER {\n  $built_in: true\n\n  %% String -> String\n  name: \"to_camel_case\"\n  impl: (s) => {return s.toCamelCase();}\n}\n\n@filter STRING_TRIM_FILTER {\n  $built_in: true\n\n  %% String -> String\n  %% ${\"  Foo  \" | trim} = \"foo\"\n  name: \"trim\"\n  impl: (s) => {return s.trim();}\n}\n\n@filter STRING_TO_TITLE_CASE_FILTER {\n  $built_in: true\n\n  %% String -> String\n  name: \"to_title_case\"\n  impl: (s) => {return s.toTitleCase();}\n}\n\n@filter STRING_DOWNCASE_FILTER {\n  $built_in: true\n\n  %% String -> String\n  name: \"downcase\"\n  impl: (s) => {return s.toLowerCase();}\n}\n\n@filter STRING_PREPEND_FILTER {\n  $built_in: true\n\n  %% String -> String\n  name: \"prepend\"\n  impl: (s, t) => {return t + s;}\n}\n\n@filter STRING_UPCASE_FILTER {\n  $built_in: true\n\n  %% String -> String\n  name: \"upcase\"\n  impl: (s) => {return s.toUpperCase();}\n}\n\n@filter STRING_PLURALIZE_FILTER {\n  $built_in: true\n\n  %% String -> String\n  name: \"pluralize\"\n  impl: (s) => {return pluralize(s);}\n}\n\n@filter STRING_POSSESSIVE_FILTER {\n  $built_in: true\n\n  %% String -> String\n  name: \"possessive\"\n  impl: (s) => {return s.possessive();}\n}\n\n@filter STRING_SPLIT_FILTER {\n  $built_in: true\n\n  %% String -> Array\n  name: \"split\"\n  impl: (s, p) => {return s.split(p);}\n}\n\n@filter STRING_STARTS_WITH_FILTER {\n  $built_in: true\n\n  %% String -> Bool\n  name: \"starts_with\"\n  impl: (s, search) => {return s.startsWith(search);}\n}\n\n@filter STRING_ENDS_WITH_FILTER {\n  $built_in: true\n\n  %% String -> Bool\n  name: \"ends_with\"\n  impl: (s, search) => {return s.endsWith(search);}\n}\n\n@filter STRING_CONTAINS_FILTER {\n  $built_in: true\n\n  %% String -> Bool\n  name: \"contains\"\n  impl: (s, search) => {return s.includes(search);}\n}\n\n@filter STRING_QUOTED_FILTER {\n  $built_in: true\n\n  %% String -> String\n  name: \"quoted\"\n  impl: (s) => {return `\'${s}\'`;}\n}\n\n@filter STRING_DOUBLE_QUOTED_FILTER {\n  $built_in: true\n\n  %% String -> String\n  name: \"dquoted\"\n  impl: (s) => {return `\"${s}\"`;}\n}\n\n@filter STRING_INDEFINITE_ARTICLE_FILTER {\n  $built_in: true\n\n  %% String -> String\n  name: \"i_article\"\n  impl: (s) => {\n    const article = s.indefiniteArticle();\n    return `${article} ${s}`;\n  }\n}\n\n@filter ARRAY_LENGTH_FILTER {\n  $built_in: true\n\n  %% Array -> Integer\n  name: \"length\"\n  impl: (arr) => {return arr.length;}\n}\n\n@filter ARRAY_TAKE_FILTER {\n  $built_in: true\n\n  %% Array, n -> Array\n  name: \"take\"\n  impl: (arr, n) => {return arr.take(n);}\n}\n\n@filter ARRAY_AT_FILTER {\n  $built_in: true\n\n  %% Array, n -> value\n  name: \"at\"\n  impl: (arr, n) => {return arr[n];}\n}\n\n%% Most of the following filters have been superceded either by the revised\n%% link syntax, or components.\n\n@filter EVENT_LINK_FILTER {\n  $built_in: true\n\n  %% String -> Link\n  %% ${<Title> | event: <event-id>}\n  %% ${\"Go here\" | event: \"fudge\"}\n\n  name: \"event\"\n  impl: (event, title) => {\n    return \"<a href=\'javascript:void(0);\' class=\'event\' data-event=\'\" + event + \"\'>\" + title + \"</a>\";\n  }\n}\n\n@filter DYN_LINK_FILTER {\n  $built_in: true\n\n  %% ${card | dyn_link: <action>}\n  %% ${card | dyn_link: \"can_attack\"}\n  name: \"dyn_link\"\n  impl: (card, action) => {\n    const link_handler = card.getAttribute(action);\n    if(typeof(link_handler) != \"function\") {\n      throw `Attribute |${action}| of card |${card.id}| is not a handler function!`;\n    } else {\n      let link = new RezDynamicLink(card);\n      link_handler(link);\n      if(!link.choosen) {\n        throw new Error(\"Choice must call one of hide/deny/allow!\");\n      }\n      if(link.display) {\n        return link.markup;\n      } else {\n        return \"\";\n      }\n    }\n  }\n}\n\n@filter RENDER {\n  $built_in: true\n\n  %% Template, View -> String\n\n  %% The render filter bends the renderer to allow inline rendering of templates\n  %% it depends upon the $block binding that makes the view available to rendering\n  %% blocks. You pass (template, $block) and it will treat the template as a block\n  %% with the current block as parents (ergo all parent bindings are available\n  %% to the rendering block).\n\n  name: \"render\"\n  impl: (source_obj, attribute, parent_block) => {\n    const template = source_obj.getAttribute(attribute);\n    if(typeof(template) === \"undefined\") {\n      throw `Unable to render ${attribute} of ${source_obj.id} as it is not defined`;\n    } else if(typeof(template) === \"string\") {\n      return template;\n    } else {\n      const render_source = new RezSyntheticSource(template);\n      const sub_block = new RezBlock(\"block\", render_source);\n      sub_block.parent_block = parent_block;\n      return sub_block.renderBlock();\n    }\n  }\n}\n\n%% ----------------------------------------------------------------------------\n%% Useful components\n%% ----------------------------------------------------------------------------\n\n@component embed_card (bindings, assigns, content) => {\n  let blockSource;\n  if(typeof(assigns.card) === \"string\") {\n    // We expect the id of a card\n    blockSource = $t(assigns.card, \"card\", true);\n  } else if(typeof(assigns.card) === \"object\" && assigns.card instanceof RezCard) {\n    // Otherwise it should be a reference to a card\n    blockSource = assigns.card;\n  } else {\n    throw new Error(`Attempt to embed card with bad \'card\' assign! (${typeof(assigns.card)})`);\n  }\n  blockSource.$parent = bindings.card;\n  const block = new RezBlock(\"block\", blockSource);\n  block.parentBlock = bindings.card.parentBlock;\n  return block.html();\n}\n\n@component img (bindings, assigns, content) => {\n  const asset = $(assigns[\"name\"]);\n  const path = asset.$dist_path;\n\n  // Use assigns width/height if provided, otherwise use asset dimensions\n  const w = assigns[\"width\"] || asset.width;\n  const h = assigns[\"height\"] || asset.height;\n\n  // Extract name, width and height from assigns so we don\'t duplicate them\n  const { name, width, height, ...otherAssigns } = assigns;\n\n  // Build additional attributes string from remaining assigns\n  const otherAttributes = Object.entries(otherAssigns)\n    .map(([key, value]) => `${key}=\"${value}\"`)\n    .join(\" \");\n\n  return `<img src=\"${path}\" width=\"${w}\" height=\"${h}\" ${otherAttributes} />`;\n}\n\n%% ----------------------------------------------------------------------------\n%% A scene that handles loading a game\n%% ----------------------------------------------------------------------------\n\n@scene $load_game {\n  $built_in: true\n\n  initial_card_id: #$load_game_form\n  layout: ```\n  ${content}\n  ```\n  layout_mode: :single\n}\n\n@card $load_game_form {\n  $built_in: true\n\n  content: ```\n  <form rez-live name=\"load_form\">\n    <input type=\"file\" name=\"data\"/>\n    <input type=\"submit\"/>\n  </form>\n  ```\n\n  on_load_form: (card, data) => {\n    console.log(\"In the load form handler!\");\n    const form = data.form;\n    const file_input = form.querySelector(\"input[type=file]\");\n    const [file] = file_input.files;\n    const reader = new FileReader();\n    reader.addEventListener(\"load\", function() {\n      $game.load(reader.result);\n    });\n    reader.readAsText(file);\n    return RezEvent.noop();\n  }\n}\n\n%% ----------------------------------------------------------------------------\n%% Default Behaviour Conditions & Actions\n%% ----------------------------------------------------------------------------\n\n@system $actor_behaviours {\n  $built_in: true\n\n  enabled: false\n  priority: 10\n  after_event: (system, evt, result) => {\n    if(evt.target.dataset.event === \"behaviours\") {\n      console.log(\"Running actor_behaviours system\");\n      const game = evt.game;\n      const actors = game.getAll(\"actor\").filter((actor) => {return actor.hasAttribute(\"behaviours\")});\n      actors.forEach((actor) => {\n        const btree = actor.getAttributeValue(\"behaviours\");\n        btree.executeBehaviour();\n      });\n    }\n    return result;\n  }\n}\n\n%% Core behaviours\n%% These behaviours model the \'generic\' behaviours implemented in the\n%% Crysis engine:\n%% https://docs.cryengine.com/display/CEPROG/Modular+Behavior+Tree+Nodes\n%% See the Behaviour Tree part of the user guide for more information.\n%%\n%% Core behaviours use an id beginning with a dollar to avoid conflict\n%% with author generated id\'s.\n\n@behaviour $select {\n  %% The $select behaviour executes it\'s children in turn until one of them\n  %% succeeds, then $select succeeds. If no child succeeeds then $select fails.\n\n  $built_in: true\n  $template: true\n  options: []\n  min_children: 2\n\n  execute: (behaviour) => {\n    for(const child of behaviour.children) {\n      if(child.executeBehaviour()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n@behaviour $select_r {\n  %% The $select_r behaviour is similar to $select except that each time it\n  %% executes, it executes its children in random order.\n\n  $built_in: true\n  $template: true\n  options: []\n  min_children: 2\n\n  execute: (behaviour) => {\n    const indices = Math.range(0, behaviour.childCount-1).fy_shuffle();\n    for(const i of indices) {\n      const child = behaviour.getChildAt(i);\n      if(child.executeBehaviour()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n@behaviour $select_p {\n  %% The $select_p behaviour is similar to SELECT except that before ticking any\n  %% child it does a probability check using the \"p\" option. If the check passes\n  %% it ticks the child, otherwise it moves on to the next child. If a child\n  %% succeeds $select_p succeeds. If no child succeeds, $select_p fails.\n\n  $built_in: true\n  $template: true\n  options: [:p]\n  min_children: 2\n\n  configure: (behaviour) => {\n    const p = behaviour.intOption(\"p\");\n    if(p < 0 || p > 100) {\n      throw \"Behaviour: \" + behaviour.id + \" invalid \'p\' option specified.\";\n    }\n  }\n\n  execute: (behaviour) => {\n    const p = behaviour.intOption(\"p\");\n    const die = new RezDie(1, 100, 0);\n    for(const child of behaviour.children) {\n      if(die.roll() < p) {\n        if(child.executeBehaviour()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\n@behaviour $sequence {\n  %% The $sequence behaviour executes its children in turn. If they all succeed\n  %% then the $sequence succeeds. If a child fails the $sequence fails and does\n  %% not execute any further children.\n\n  $built_in: true\n  $template: true\n  options: []\n  min_children: 2\n\n  execute: (behaviour) => {\n    for(const child of behaviour.children) {\n      if(!child.executeBehaviour()) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\n@behaviour $loop {\n  %% The $loop behaviour takes one child and executes it \'count\' times. If it\n  %% succeeds on every repetition the $loop succeeds. If the child ever fails\n  %% the $loop fails.\n\n  $built_in: true\n  $template: true\n  options: [:count]\n  min_children: 1\n  max_children: 1\n\n  execute: (behaviour) => {\n    const count = behaviour.intOption(\"count\");\n    for(let i=0; i<count; i++) {\n      if(!behaviour.firstChild.executeBehaviour()) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\n@behaviour $loop_until {\n  %% The $loop_until behaviour takes one child and executes it until it\n  %% succeeds. The \'attempts\' option specifies how many times it will\n  %% executed. If the child ever succeeds, $loop_until succeeds. If the\n  %% child doesn\'t succeed in the number of attempts then $loop_until fails.\n\n  $built_in: true\n  $template: true\n  options: [:attempts]\n  min_children: 1\n  max_children: 1\n\n  execute: (behaviour) => {\n    const attempts = behaviour.intOption(\"attempts\");\n    for(let i=0; i<attempts; i++) {\n      if(behaviour.firstChild.executeBehaviour()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n@behaviour $maybe {\n  %% The $maybe behaviour takes one child and based on the option \"p\" determines\n  %% whether to execute it or not. If it executes the child then $maybe succeeds\n  %% if the child succeeds or fails if the child fails. If it doesn\'t execute\n  %% the child then $maybe fails.\n\n  $built_in: true\n  $template: true\n  options: [:p]\n  min_children: 1\n  max_children: 1\n\n  execute: (behaviour) => {\n    const p = behaviour.intOption(\"p\");\n    const die = new RezDie(1, 100, 0);\n\n    if(die.roll() < p) {\n      return behaviour.firstChild.executeBehaviour();\n    } else {\n      return false;\n    }\n  }\n}\n\n@behaviour $either {\n  %% The $either behaviour takes two children and based on the probability\n  %% option \"p\" determines whether to execute the first or second child.\n  %% Having decided which child to execute $either succeeds or fails based\n  %% on whether the selected child succeeds or fails.\n\n  $built_in: true\n  $template: true\n  options: [:p]\n  min_children: 2\n  max_children: 2\n\n  execute: (behaviour) => {\n    const p = behaviour.intOption(\"p\");\n    const die = new RezDie(1, 100, 0);\n    const roll = die.roll();\n\n    if(roll < p) {\n      return behaviour.firstChild.executeBehaviour();\n    } else {\n      return behaviour.secondChild.executeBehaviour();\n    }\n  }\n}\n\n@behaviour $random_choice {\n  %% The $random_choice behaviour takes two or more children. When $random_choice\n  %% executes it selects a child at random and executes it. If that child\n  %% succeeds then $random_choice succeeds, otherwise it fails.\n\n  $built_in: true\n  $template: true\n  options: []\n  min_children: 2\n\n  execute: (behaviour) => {\n    const die = new RezDie(1, behaviour.childCount, -1);\n    const child = behaviour.getChildAt(die.roll());\n    return child.executeBehaviour();\n  }\n}\n\n@behaviour $random_each {\n  %% The $random_each behaviour takes two or more children. When $random_each\n  %% executes it selects a child, without replacement, and executes it. If\n  %% the selected child succeeds then $random_each succeeds, otherwise it\n  %% fails. Without replacement means that no child can be selected twice\n  %% until all children have been selected at least once.\n\n  $built_in: true\n  $template: true\n  options: []\n  min_children: 2\n\n  execute: (behaviour) => {\n    const stateKey = `behavior_${behaviour.id}_state`;\n    let child_walk = behaviour.owner.getAttribute(stateKey);\n\n    if(typeof(child_walk) == \"undefined\" || child_walk.length == 0) {\n      child_walk = Array.from(Array(behaviour.childCount).keys()).fy_shuffle();\n    }\n\n    const child_idx = child_walk.shift();\n    behaviour.owner.setAttribute(stateKey, child_walk);\n\n    const child = behaviour.getChildAt(child_idx);\n    return child.executeBehaviour();\n  }\n}\n\n@behaviour $always {\n  %% The $always behaviour takes one child and executes it, $always succeeds\n  %% regardless of whether the child succeeds.\n\n  $built_in: true\n  $template: true\n  options: []\n  min_children: 1\n  max_children: 1\n\n  execute: (behaviour) => {\n    behaviour.firstChild.executeBehaviour();\n    return true;\n  }\n}\n\n@behaviour $never {\n  %% The $never behaviour takes one child and executes it, $never fails regardless\n  %% of whether the child fails.\n\n  $built_in: true\n  $template: true\n  options: []\n  min_children: 1\n  max_children: 1\n\n  execute: (behaviour) => {\n    behaviour.firstChild.executeBehaviour();\n    return false;\n  }\n}\n\n@behaviour $invert {\n  %% The $invert behaviour takes one child and executes it. If the child succeeds\n  %% then $invert will fail. If the child fails then $invert will succeed.\n\n  $built_in: true\n  $template: true\n  options: []\n  min_children: 1\n  max_children: 1\n\n  execute: (behaviour) => {\n    return !behaviour.firstChild.executeBehaviour();\n  }\n}\n\n@behaviour $fail {\n  %% The $fail behaviour automatically fails.\n\n  $built_in: true\n  $template: true\n  options: []\n  max_children: 0\n\n  execute: (behaviour) => {\n    return false;\n  }\n}\n\n@behaviour $succeed {\n  %% The $succeed behaviour automatically succeeds.\n\n  $built_in: true\n  $template: true\n  options: []\n  max_children: 0\n\n  execute: (behaviour) => {\n    return true;\n  }\n}\n","src/player.rez": "@actor player {\n  name: \"San Holo\"\n\n  credits: 2000\n}","src/scenes.rez": "%(scenes/char_sheet.rez)\n","src/scenes/char_sheet.rez": "@keybinding shift+C :show_character_sheet\n\n@game {\n  on_show_character_sheet: () => {\n    console.log(\"Run show_character_sheet event handler!\");\n    if($game.current_scene_id === \"sc_char_sheet\") {\n      return RezEvent.sceneResume();\n    } else {\n      return RezEvent.sceneInterlude(\"sc_char_sheet\");\n    }\n  }\n}\n\n@scene sc_char_sheet {\n  initial_card_id: #c_char_sheet\n  bindings: [\n    player: #player\n  ]\n}\n\n@card c_char_sheet {\n  content: ```\n  <div>Character Sheet</div>\n  <div class=\"columns\">\n    <div class=\"column is-one-fifth\">\n      <div>Name</div>\n      <div>${player.name}</div>\n      <div>Credits</div>\n      <div>${player.credits}</div>\n    </div>\n    <div class=\"column\">\n      ${content}\n    </div>\n  </div>\n  ```\n}","src/slipstream.rez": "%%\n%% Game created with Rez 1.8.6\n%% http://rez-lang.com/\n%% By Matt Mower <self@mattmower.com>\n%% Released 2022-2025 under the GPLv3 license\n%%\n\n%(../lib/stdlib.rez)\n\n@const build = 1\n\n@asset _ALPINE_JS {\n  $built_in: true\n  file_name: \"alpinejs.min.js\"\n  $js_defer: true\n  $pre_runtime: true\n  wuggle: true\n}\n\n@asset _BULMA_CSS {\n  $built_in: true\n  file_name: \"bulma.min.css\"\n}\n\n@asset js_popper {\n  $pre_runtime: true\n\n  file_name: \"popper.min.js\"\n}\n\n@asset js_tippy {\n  $pre_runtime: true\n\n  file_name: \"tippy.min.js\"\n}\n\n@pragma(after_process_ast) source_explorer\n\n@keybinding Escape :end_interlude\n\n@game {\n  name: \"slipstream\"\n  title: \"Slipstream\"\n  author: \"Mr Sandbags & HAL-9000\"\n  author_email: \"self@mattmower.com\"\n  game_homepage: \"https://rez-lang.com/\"\n\n  IFID: \"45BBD19C-CA0B-11F0-94B1-CA41670CF0BA\"\n  archive_format: 1\n\n  version: \"1.0\"\n  created: \"2025-11-25 14:30:21.191257Z\"\n\n  initial_scene_id: #sc_main\n\n  layout: ```\n  <!-- Main Content -->\n  <section class=\"main-content is-fullheight\">\n    <div class=\"container\">${content}</div>\n  </section>\n  <!-- End -->\n  ```\n\n  on_after_render: () => {\n    document.querySelectorAll(\"[data-tippy-content]\").forEach(el => tippy(`#${el.id}`, {allowHTML: true}));\n  }\n\n  on_end_interlude: () => {\n    if($game.canResume()) {\n      return RezEvent.sceneResume();\n    } else {\n      return RezEvent.noop();\n    }\n  }\n}\n\n%(scenes.rez)\n%(player.rez)\n\n@scene sc_main {\n  initial_card_id: #c_intro\n}\n\n@card c_intro {\n  bindings: [\n    source_explorer: #asset_source_explorer_html\n  ]\n  content: ```\n  <section class=\"hero\">\n    <div class=\"hero-body\">\n      <p class=\"title\">${card.game.title} ${$build}</p>\n      <p class=\"subtitle\">From <span class=\"has-text-primary\">${card.game.author}</span></p>\n    </div>\n    <div class=\"box\">\n      <p>Start adding your content</p>\n      <p>Explore the <a target=\"_blank\" href=${source_explorer.$dist_path}>source</a>.</p>\n      <p>See the <a href=\"http://rez-lang.com/\" target=\"_blank\">online documentation</a> for more information.</p>\n    </div>\n  </section>\n  ```\n}\n"},
    selected: "src/slipstream.rez",
    select(path) {
      this.selected = path;
    }
  }
}
</script>

</body>
</html>
